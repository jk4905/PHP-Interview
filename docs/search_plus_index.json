{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 12:15:05 "},"PHP-基础知识/01.类型.html":{"url":"PHP-基础知识/01.类型.html","title":"01.类型","keywords":"","body":"01.类型 php 开启 '' 短标签：在 php.ini 中找到 short_open_tag 改为 true。（不建议使用） 如果文本为纯 PHP 代码，则最好删除 PHP 结束标记，这样可以防止意外加入的空格和换行符，会导致 PHP 输出本无意输出的空格。 php 的 ?> 结尾自带一个分号，如 合法。 1、类型 PHP 支持 9 种原始数据类型 基本类型，标量 整形 integer 字符串 string 浮点型 float 布尔型 boolean复合类型 对象 object 数组 array 可调用 callback其他 资源 resource NULL 其类型判断可通过：is_integer , is_string() , is_float() , is_bool() , is_array() , is_object() , is_resource() , is_null() , is_numeric() , is_scalar() 判断是否是标量 1.1 Boolean 布尔类型 $bool = True; // 不区分大小写 其他类型转换 当其他类型转换为 Boolean 时，以下 7 个会被认为是 FALSE： 布尔 FALSE 本身 整型 0 浮点型 0.0 空字符串 '' 以及 '0' 不包含任何元素的空数组 [] 特殊类型 NULL 从空标记生成的 SimpleXML 对象。 1.2 Integer 整型 32 位系统中范围为 -2^31-1 ~ 2^31-1 64 位系统中范围为 -2*63-1 ~ 2^63-1 123 -123 0123 #八进制 0x123 #十六进制 当给定的数超过范围时，php 会自动将其变为 浮点型（Float） 。同样通过计算的超过范围也会返回 浮点型（Float） 。做除法运算时，除不尽的也会变成 浮点型（Float） 。 PHP 7.0.0 起，NaN 和 Infinity 在转换成 integer 时，不再是 undefined 或者依赖于平台，而是都会变成零。 其他类型转换 资源类型 Resource 将返回 php 运行时 resource 分配的唯一资源号 布尔型 Boolean false=0，true=1 浮点型 Float 通常情况下是向下取整，但是由于精度问题可能造成无法预估的情况 echo (int) ( (0.1+0.7) * 10 ); // 显示 7! 字符串 String 如果字符串中没有包含 ','，'E'或'e'，该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 'e' 或 'E' 后面跟着一个或多个数字构成。 1.3 Float 浮点型 浮点数精度有限，取决于系统。永远不要相信浮点数最后一位。也不要直接比较两个浮点数，如需要请使用精度函数 bc。 字符串转换为数值 1.4 String 字符串 字符串有 4 种表示方法 单引号，单引号中变量不被解析。如果要表达单引号本身需要加反斜线\\。 $a = 'abc'; $b = '$a';//$a $c = \"$a\"; //abc 双引号，双引号中的变量以及特殊字符会被解析。\\n 换行（ASCII 字符集中的 LF 或 0x0A (10)） \\r 回车（ASCII 字符集中的 CR 或 0x0D (13)） \\t 水平制表符（ASCII 字符集中的 HT 或 0x09 (9)） \\\\ 反斜线 \\$ 美元标记 \\\" 双引号 heredoc 结构是一种提供一个开始标记和一个结束标记。方便书写大段的字符串。结束标记必须顶格写。类似双引号。单引号不转义。变量解析 foo = 'Foo'; $this->bar = array('Bar1', 'Bar2', 'Bar3'); } } $foo = new foo(); $name = 'MyName'; echo foo. Now, I am printing some {$foo->bar[1]}. This should print a capital 'A': \\x41 EOT; // 输出 My name is \"MyName\". I am printing some Foo. Now, I am printing some Bar2. This should print a capital 'A': A Nowdoc 结构是类似于单引号字符串的。Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作 nowdoc前需要加上单引号。 string中的字符可以通过一个从 0 开始的下标，用类似 Array 结构中的方括号包含对应的数字来访问和修改，也可以通过花括号{}。 $a = 'start'; echo $a[0]; // 输出 s echo $a{0}; // 输出 s 字符串的连接使用 . 来完成。 $a = 'a'; $b = 'b'; echo $a.$b; // ab 复杂（花括号）语法，可以在字符串中使用复杂表达式。其方式为在 string 中将表达式通过 {}（花括号）括起来。变量$符号必须紧挨{（左花括号）。 $great = 'fantastic'; echo \"This is {$great}\"; // 有效 echo \"This is { $great}\"; // 无效 echo \"This is ${great}\"; // 有效 echo \"This square is {$square->width}00 centimeters broad.\"; // 有效 echo \"This works: {$arr['key']}\";// 有效，只有通过花括号语法才能正确解析带引号的键名 echo \"This works: {$arr[4][3]}\"; // 有效 echo \"This works: {$arr['foo'][3]}\"; // 有效，当在字符串中使用多重数组时，一定要用括号将它括起来 // 有效 echo \"This works: \" . $arr['foo'][3]; echo \"This works too: {$obj->values[3]->name}\"; echo \"This is the value of the var named $name: {${$name}}\"; echo \"This is the value of the var named by the return value of getName(): {${getName()}}\"; echo \"This is the value of the var named by the return value of \\$object->getName(): {${$object->getName()}}\"; 转换为字符串 boolean 的 true 会被转换为 string \"1\"，而 false 会被转换为 string ‘’。 整数和浮点数就直接被装换为字面的 string。 array 类型会被转换为 string “Array”。 object 类型会被转换为 string “Object”。 资源 resource 总会被转变成 \"Resource id #1\" 这种结构的字符串。 NULL 总是被转变成空字符串。 1.5 Array 数组 PHP 中的数组是一个有序映射。映射是一种把 values 映射到 keys 的类型。 $a = array(1,2,3); // 索引数组 $b = [ 'a'=>'abc', 'd'=>'def', ]; // 简写 php5.4+，关联数组 键名 包含有合法整型值的字符串会被转换为整型。例如键名 \"8\" 实际会被储存为 8。但是 \"08\" 则不会强制转换，因为其不是一个合法的十进制数值。 浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。 布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。 Null 会被转换为空字符串，即键名 null 实际会被储存为 \"\"。 数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。 1.6 Object 对象 通过 new 来实例化对象 class a{} $obj = new a(); 1.7 Resource 资源 资源类型是保持外部的一个引用。如数据库的链接，文件的句柄等。 $fp = fopen(\"./a.log\");//resource 1.8 Null Null 表示一个变量没有值。Null 类型唯一的值就是 Null。 3 种情况下会被认为是 Null 变量没有赋值 变量赋值 Null 变量被 unset();$a = null // null $b;//var_dump($b); null $c = 1; unset($c);//var_dump($c); null 1.9 Callback 类型 一些函数如 call_user_func() 或 usort() 可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。 // An example callback function function my_callback_function() { echo 'hello world!'; } // An example callback method class MyClass { static function myCallbackMethod() { echo 'Hello World!'; } } // Type 1: Simple callback call_user_func('my_callback_function'); // Type 2: Static class method call call_user_func(array('MyClass', 'myCallbackMethod')); // Type 3: Object method call $obj = new MyClass(); call_user_func(array($obj, 'myCallbackMethod')); // Type 4: Static class method call (As of PHP 5.2.3) call_user_func('MyClass::myCallbackMethod'); Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/02.变量与常量.html":{"url":"PHP-基础知识/02.变量与常量.html","title":"02.变量与常量","keywords":"","body":"02.变量与常量 php 变量通常以美元 $ 符号开头，以字母、下划线开头，后面跟任意字母、数字、下滑线。 php 的变量大小写敏感，通常以小驼峰或单词以下划线隔开来命名。如 $productSku 或 $product_sku $this 是一个特殊的变量，不能定位成 this 变量。 $a; // 合法 $_a; // 合法 $2a; // 非法 1. 变量的引用赋值 通过给变量钱加 & 来赋值。只能引用有值的变量。 $a = 4; $b = &$a; $b = 5; echo $a; // 5 echo $b; // 5 2. 预定义变量 超全局变量：在全部作用域下始终可用的内置变量 超全局变量 解释 $GLOBALS 引用全局作用域中所有的全部变量 $_GET HTTP GET 变量 $_POST HTTP POST 变量 $_REQUREST HTTP Request 变量 $_SERVER 服务器和执行环境信息 $_FIELS 文件上传变量 $_SESSION Session 变量 $_COOKIE Cookie 变量 $_ENV 环境变量 预定义变量 |预定义变量|解释| |:--:|:--:| |$php_errormsg | 前一个错误信息| |$HTTP_RAW_POST_DATA | 原生POST数据| |$http_response_header | HTTP 响应头| |$argc | 传递给脚本的参数数目| |$argv | 传递给脚本的参数数组| 3. 可变变量 变量名称本身是个变量的变量叫可变变量1 超全局变量和 $this 不可用作可变变量。 $a = 'b'; $b = '4'; echo $$a; // 4 4. 变量的作用域 在文件最外层定义的变量是全局变量。 函数内部的变量是局部变量，局部变量只能在函数内访问。 $a = 123; function test(){ echo $a; } echo $a; // 123; test(); // 无输出 在函数内通过 static 修饰的变量，仅在局部函数内存在，当程序作用完之后离开时，静态变量不会消失，等全部程序执行完成后才会销毁。 function test(){ static $a = 0; // 正确 static $a = 1; // 会报错，static 不能重复通过 static 定义。 $a++; echo $a; } test(); // 1 test(); // 2 在函数内部通过 global 修饰函数外部全局变量，可以使全局变量能够作用于局部函数内部 5. 常量 常量是定义之后就不能更改的变量。通常由 define() 函数来定义。常量通常大写，其他命名规则与变量类似。 define('IS_DEBUG',0); 在常量中还有一些系统预定义好的常量。如 PHP_EOL 换行。 8 个魔术常量 常量 解释 LINE 文件中当前行号 FILE 返回包含当前文件名的绝对路径 DIR 返回当前文件所在文件夹的绝对路径（结尾不包含反斜杠/） FUNCTION 返回当前函数的名称 CLASS 返回当前类的名称 TRAIT 返回 trait 的名字 METHOD 返回类的方法名 NAMESPACE 返回命名空间 namespace App; class test{ public function a(){ echo __CLASS__.PHP_EOL; echo __METHOD__.PHP_EOL; echo __NAMESPACE__.PHP_EOL; echo __FUNCTION__.PHP_EOL; } } $obj = new test(); $obj->a(); // 输出 App\\test // App\\test::a // App // a Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/03.运算符.html":{"url":"PHP-基础知识/03.运算符.html","title":"03.运算符","keywords":"","body":"03.运算符 1.运算符优先级 结合方向 运算符 附加信息 无 clone new clone 和 new 左 [ array() 右 \\ 算术运算符 右 ++ -- ~ (int) (float) (string) (array) (object) (bool) @ 类型和递增／递减 无 instanceof 类型 右 ! 逻辑运算符 左 ** / %* 算术运算符 左 + - . 算术运算符和字符串运算符 左 >> 位运算符 无 > >= 比较运算符 无 == != === !== <> 比较运算符 左 & 位运算符和引用 左 ^ 位运算符 左 ｜ 位运算符 左 && 逻辑运算符 左 ｜｜ 逻辑运算符 左 ?? 比较运算符 左 ? : ternary right = += -= =* *= /= .= %= &= ｜= ^= >>=* 赋值运算符 左 and 逻辑运算符 左 xor 逻辑运算符 左 or 逻辑运算符 $a = 5, $b = 5 ?> 2. 算数运算符 $a = 5; $b = 2; echo $a+$b; // 加法 结果：7 echo $a-$b; // 减法 结果：3 echo $a*$b; // 乘法 结果：10 echo $a/$b; // 除法取商 结果：2 echo $a%$b; // 取模 结果：1 echo $a**$b; // 指数乘积 结果：25 // 取模例子 取模正负只看前一个值得正负 echo (5 % 3); // 结果：2 echo (-5 % 3); // 结果：-2 echo (5 % -3); // 结果：2 echo (-5 % -3); // 结果：-2 3.赋值运算符 $b = 4; $a = $b +=5; // $a = $b = ($b+5) a b 都等于 9 $c = 'hello'; $c .= 'world'; // hello world $d = 4; $e = &d; // 引用赋值 $e = 5; // d e 都等于 5 4.位运算符 $a \\&\\ $b And（按位与） 将把 $a 和 $b 中都为 1 的位设为 1。 $a \\｜$b Or（按位或） 将把 $a 和 $b 中任何一个为 1 的位设为 1。 $a ^ $b Xor（按位异或） 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。 ~ $a Not（按位取反） 将 $a 中为 0 的位设为 1，反之亦然。 $a Shift left（左移） 将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。 $a >> $b Shift right（右移） 将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。 5.比较运算符 当比较有字符串时，会把字符串转换为数字来进行比较 $a == $b 等于 TRUE，如果类型转换后 $a 等于 $b。 $a === $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。 $a != $b 不等 TRUE，如果类型转换后 $a 不等于 $b。 $a <> $b 不等 TRUE，如果类型转换后 $a 不等于 $b。 $a !== $b 不全等 TRUE，如果 $a 不等于 $b，或者它们的类型不同。 $a 小与 TRUE，如果 $a 严格小于 $b。 $a > $b 大于 TRUE，如果 $a 严格大于 $b。 $a 小于等于 TRUE，如果 $a 小于或者等于 $b。 $a >= $b 大于等于 TRUE，如果 $a 大于或者等于 $b。 $a $b 太空船运算符（组合比较符） 当$a小于、等于、大于$b时 分别返回一个小于、等于、大于0的integer 值。 PHP7开始提供. $a ?? $b ?? $c NULL 合并操作符 从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL。PHP7开始提供。 echo 1 1; // 0 echo 2 1; // 1 echo 1 2; // -1 echo 'a' 'b'; // -1 echo 'a' 'a'; // 0 echo 'b' 'a'; // 1 echo \"a\" \"aa\"; // -1 echo \"zz\" \"aa\"; // 1 echo [] []; // 0 echo [1, 2, 3] [1, 2, 3]; // 0 echo [1, 2, 3] []; // 1 echo [1, 2, 3] [1, 2, 1]; // 1 echo [1, 2, 3] [1, 2, 4]; // -1 多种类型比较 运算数 1 运算数 2 结果 null 或 string string null 转换为'',再比较 bool 或 null 任何其他类型 null 转换为 false，再比较 object object 除非内部结构相同，否则无法比较。 == 属性和值一样则相等。 === 判断是否为同一对象 string，resource 或 number string，resource 或 number 都转换为数字比较 array array 较少成员的较小。如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较 array 任何其它类型 array 总是更大 object 任何其它类型 object 总是更大 6.错误控制运算符 PHP 支持在表达式前加 @ 。表示忽略这个表达式的可能产生的任何错误 7.执行运算符 PHP 支持一个执行运算符：反引号(`)。PHP 将其作为 shell 命令进行执行，并返回结果。 反引号不能在双引号中执行。 反引号不能再激活了安全模式或者关闭了 shell_exec() 时执行。 ```php $a =ls -al`; echo $a; // 结果 -rw-r--r--@ 1 jupiter.k staff 241684 Mar 18 23:30 a.txt #### 8.递增/递减运算符 ```php $a = 5; $a++; // 先返回5，$a 再加 1 ++$a; // $a 先加 1，再返回 6 9.逻辑运算符 $a and $b And（逻辑与） TRUE，如果 $a 和 $b 都为 TRUE。 $a or $b Or（逻辑或） TRUE，如果 $a 或 $b 任一为 TRUE。 $a xor $b Xor（逻辑异或） TRUE，如果 $a 或 $b 任一为 TRUE，但不同时是。 ! $a Not（逻辑非） TRUE，如果 $a 不为 TRUE。 $a && $b And（逻辑与） TRUE，如果 $a 和 $b 都为 TRUE。 $a ｜｜ $b Or（逻辑或） TRUE，如果 $a 或 $b 任一为 TRUE。 10.字符串连接符 字符串连接符号 点(.) $a = 1; $b = 222 echo $a . $b; //1222 11.类型运算符 instanceof 用于确定一个 PHP 变量是否属于某一类 $c = new C(); $c instanceof C; Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/04.流程控制.html":{"url":"PHP-基础知识/04.流程控制.html","title":"04.流程控制","keywords":"","body":"04.流程控制 1. if、else if($a == 1) { echo '1'; }else if($a == 2) { echo '2'; }else{ echo 'other'; } #简写 不推荐 if ($a == 1): echo \"1\"; else: echo \"else\"; endif; 2.switch switch 类似于一系列的 if else。每个 case 下都有一个 break。如果没有则继续往下执行。 if($a == 1) { echo '1'; }else if($a == 2) { echo '2'; }else{ echo 'other'; } # swtich switch ($a) { case 1: echo '1'; break; case 2: echo '2'; break; default: echo 'other'; break; } // 其结果只能是其中一个。 switch ($a) { case 1: echo '1'; case 2: echo '2'; default: echo 'other'; break; } // 若 $a=1 , 则值为 12other 3.while、do while while 和 do while都是满足条件后才循环，不满足则跳出。 do while 相比 while 是先执行一次再判断。 $a = 10; while($a>1) { echo $a--;//1098765432 } #do while $b = 1; do{ echo $b; //1 }while($b>1) 4.for foreach for 循环是 PHP 中最复杂的循环结构。它的行为和 C 语言的相似 for (expr1; expr2; expr3){ statement } 第一个表达式（expr1）在循环开始前无条件求值（并执行）一次。 expr2 在每次循环开始前求值。如果值为 TRUE，则继续循环，执行嵌套的循环语句。如果值为 FALSE，则终止循环。 expr3 在每次循环之后被求值（并执行）。 $people = Array( Array('name' => 'Kalle', 'salt' => 856412), Array('name' => 'Pierre', 'salt' => 215863) ); for($i = 0; $i foreach 语法结构提供了遍历数组的简单方式。foreach 仅能够应用于数组和对象 引用修改后，一定要 unset 将 $value 销毁 foreach($array as $key=>$value) { } # 简写 foreach($array as $key=>$value): endforeach; #引用修改 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。 foreach (array(1, 2, 3, 4) as &$value) { $value = $value * 2; } unset($value); 5.break 、continue break 结束当前 for，foreach，while，do-while 或者 switch 结构的执行。break后面可以跟一个数字。表示跳出几重循环 for($i = 0; $i continue 在循环结构用用来跳过本次循环中剩余的代码并在条件求值为真时开始执行下一次循环 continue 接受一个可选的数字参数来决定跳过几重循环到循环结尾。默认值是 1，即跳到当前循环末尾 for($i = 0; $i 6.declare declare 结构用来设定一段代码的执行指令。declare 的语法和其它流程控制结构相似 目前只认识两个指令：ticks encoding Tick（时钟周期）是一个在 declare 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 declare 中的 directive 部分用ticks=N 来指定的 encoding 指令来对每段脚本指定其编码方式。 declare(ticks=1); // A function called on each tick event function tick_handler() { echo \"tick_handler() called\\n\"; } register_tick_function('tick_handler'); $a = 1; if ($a > 0) { $a += 2; print($a); } declare(encoding='ISO-8859-1'); 7.return 在函数中使用return 将结束函数的执行。 return 是语言结构而不是函数，因此其参数没有必要用括号将其括起来。通常都不用括号，实际上也应该不用，这样可以降低 PHP 的负担。 function f(){ return 1; echo '11';//不会执行 } #a.php #b.php // ba 8.include 、require include(path) 会按照给定的参数 进行查找，如果没有找到就到include_path中查找。如果还没有找到，那么就会抛出一个警告。 如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \\ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径。include_path就会被忽略。 require 和include查找文件基本上一致。只是require会抛出一个error错误终止代码的执行。 require 和include是一个语言构造器而不是一个函数 include 'a.php'; echo \"hello\"; # 会输出hello require 'a.php'; echo \"hello\"; # 抛出一个error hello不会输出。 9.include_once 、require_once include_once 、require_once 语句在脚本执行期间包含并运行指定文件.如果该文件中已经被包含过，则不会再次包含 include_once 会抛出warning 。require_once 会抛出error 10.goto goto操作符并不常用。用来跳转程序的一个位置。目标位置只能位于同一个文件和作用域 无法跳出一个函数或类方法，也无法跳入到另一个函数。也无法跳入到任何循环或者 switch 结构中 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/05.函数.html":{"url":"PHP-基础知识/05.函数.html","title":"05.函数","keywords":"","body":"05.函数 函数名命名规则与变量名命名规则一直，以字母或下划线打头，后面跟任意字母、数字、下划线。 要避免递归函数／方法调用超过 100-200 层，因为可能会使堆栈崩溃从而使当前脚本终止 PHP 中的所有函数和类都具有全局作用域。PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。 1.自定义函数 function 函数名(参数 1,参数 2....参数 n){ // 函数体 } 2.函数参数 可以通过参数将函数外部信息传到内部 函数可以有默认值，顺序先非默认值参数，后有默认值参数 函数的参数可以指定类型，指定的类型可以是，类名、接口名、self、array、callback。php7.0 之后支持 bool、float、int、string。 function demo(ClassName $class_name,String $arg2 = 'apple'){ } 引用参数，默认情况下传入函数的参数值是不会改变的，当需要使传入值改变时，可以使用 & 引用。 4.严格类型 默认情况下，如果能做到的话，PHP将会强迫错误类型的值转为函数期望的标量类型。 在严格类型下，则不会。并且会报错，唯一的例外时将 integer 类型传给期望是 float 类型的函数。 declare(strict_types=1); function fn2(float $a){ echo $a; } $c = 1; fn2($c); // 输出 1 function fn(int $a){ echo $a; } $c = '1';//string fn($c);// 报错 5.可变参数的参数列表 PHP 在用户自定义函数中支持可变数量的参数列表。在 PHP 5.6 及以上的版本中，由 ... 语法实现 6.返回值类型 函数的返回值可以通过 return 返回。返回任意类型，返回后立即终止函数的运行，并且将控制权返还给调用函数行。 function fn(){ return \"hello\"; } 在 php7.0 之后，可以限制返回值的类型。 当覆盖一个父类方法时，子类方法的返回值类型声明必须与父类一致。如果父类方法没有定义返回类型，那么子类方法可以定义任意的返回值类型声明。 declare(strict_types=1); function($a):float { return 1.1; } 7.可变函数 php 支持可变函数概念，即在变量后加括号()，则会调用变量值同名的函数。不能用于系统函数如 echo，print，unset()，isset()，empty()，include，require 。 function foo(){ echo 1; } $a = foo; $a(); // 输出 1 8.匿名函数 匿名函数也叫闭包函数。 闭包可以从父作用域中继承变量。 任何此类变量都应该用 use 语言结构传递进去 (function (){ echo '匿名函数'; })(); #传递参数 $a = function ($arg) { echo $arg; } $arg = 'hello'; $a($arg);//hello; # 传递外部作用域变量 $arg = 'arg'; $f = function() use($arg){ echo $arg; } $f(); Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/06.类与对象1.html":{"url":"PHP-基础知识/06.类与对象1.html","title":"06.类与对象1","keywords":"","body":"06.类与对象1 类：类是对象的类型，将现实世界的有统一特征的个体抽象出来的结果。如人类、动物类、商品。 对象：对象是类的实例。有统一特征的抽象结果的实例，单独其中一个个体，如动物类的实例可以是猫，狗。 属性：是对象的一个特征，如猫的毛色，种类。 方法：是对象能够执行的动作。如猫可以走、跑、跳、睡觉。 1.类的定义 类名的定义规则与变量、函数的命名方式相同。以字母或下划线开头，跟任意字母、数字、下划线。最后一堆花括号。 class demo{ // 声明属性 public $var = 'a default value'; // 声明方法 public function displayVar() { echo $this->var; // 表示当前对象 } } $obj = new demo(); // 实例化对象 $obj->displayVar(); // 输出 a default value // ----------------------------------------------------------------------------------------- class A { function foo() { if (isset($this)) { echo '$this is defined ('; echo get_class($this); echo \")\\n\"; } else { echo \"\\$this is not defined.\\n\"; } } } class B { function bar() { A::foo(); } } $a = new A(); $a->foo(); // $this is defined (A) A::foo(); // $this is not defined. $b = new B(); $b->bar(); // $this is defined (B) B::bar(); // $this is not defined. 2.对象的实例化 通过 new 关键字来实例化一个对象，如果该类有命名空间则需要补全命名空间或者在文件开头用 use 引用。 use App; $obj = new className(); // 也可以这样做 $a = 'className'; $obj = new $a(); 对象赋值 $instance = new SimpleClass(); $assigned = $instance; $reference = &$instance; $instance->var = '$assigned will have this value'; $instance = null; // $instance and $reference become null var_dump($instance); // null var_dump($reference); // null var_dump($assigned); // object(SimpleClass)#1 (1) 3.类的继承 一个类在声明时使用 extends 关键字来继承另一个类的属性和方法。一个类只能继承一个类，不支持多继承。 displayVar(); // 输出 Extending class // a default value ?> 4.::class 自 PHP 5.5 起，关键词 class 也可用于类名的解析。使用 ClassName::class 可以获得类名，如果该类声明了命名空间，则会包括命名空间完整显示。 5.类的属性 类的变量叫类的属性。类的声明由 public 、protected 、 private 开头，然后跟上普通变量名。 在类的成员方法中，可以通过 ->(对象运算符) 来获取，如果是静态方法，则通过 self:: 来获取。 class demo{ public $a=1; public static $b=2; public function foo(){ echo $this->$a; // 1 echo self::$b; // 2 } } $obj = new demo(); $obj->foo(); 6.类常量 在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号 类常量是一个定值。类常量使用 const 定义。访问的时候使用 self:: 访问类常量 接口（interface）中也可以定义常量。更多示例见文档中的接口部分。 class demo{ const PI=3.14; } echo demo::PI; // 3.14 7.类的自动加载 类的自动加载可以不用手动 include 各个类文件。 自动加载不可用于 PHP CLI 模式 spl_autoload_register(function ($class_name) { require_once $class_name . '.php'; }); $obj = new demo1(); 8.构造函数和析构函数 构造函数 __construct()：当实例化一个对象时，立即执行的函数，非常适合用于初始化对象。 析构函数 __destruct()：析构函数在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用parent::__construct() 试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。 name = \"MyDestructableClass\"; } function __destruct() { print \"Destroying \" . $this->name . \"\\n\"; } } $obj = new MyDestructableClass(); // 输出 In constructor // Destroying MyDestructableClass class P{ public function __construct(){ echo \"construct\"; } public function __destruct(){ echo \"destruct\"; } } $p = new P();// construct; unset($p);//destruct; ?> 9.访问控制（可见性） 对属性和方法的访问控制，可以通过，public（公有）,protected（受保护的），private（私有的）三种方式来实现。 public （默认）: 任何成员都可以访问。 protected :只能其自身或子类访问。 private : 只能自身访问。 class A{ public $name = 'a'; protected $age = 10; private $money = 100; } class B extends A{ public function test(){ echo $this->age;//a } public function testPrivate(){ echo $this->money; } } $b = new B(); echo $b->name;//a echo $b->test();//10 # 不可访问 echo $b->age;//error; #子类不能访问 echo $b->testPrivate();//error 10.范围解析操作符（::） 范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量。还可以用于覆盖类中的属性和方法。 self，parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的 当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。使用self调用父类，使用$this 调用本类。 class A{ public $name = 'a'; protected $age = 10; private $money = 100; } class B extends A{ public static $s = 's'; const PI = 111; public function test(){ echo parent::age;// 10 } public static function testStatic(){ echo self::$s; } public function testConst(){ echo self::PI; } public function testPrivate(){ echo $this->money; } } # self 和 $this class ParentClass { function test() { self::who(); // will output 'parent' $this->who(); // will output 'child' } function who() { echo 'parent'; } } class ChildClass extends ParentClass { function who() { echo 'child'; } } $obj = new ChildClass(); $obj->test();// 11.static 静态关键字 声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以） 静态属性不可以由对象通过 -> 操作符来访问。静态属性只能被初始化为文字或常量。静态属性不随着对象的销毁而销毁。 class P{ $a = \"world\"; public static function test(){ echo \"hello\".self::$a; } } p::test(); Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/07.类与对象2.html":{"url":"PHP-基础知识/07.类与对象2.html","title":"07.类与对象2","keywords":"","body":"07.类与对象2 1.抽象类 PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。当一个类中有一个方法是抽象方法则，这个类就是抽象类 继承一个抽象类后，子类必须实现抽象类中所有抽象方法。 某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。 此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。 abstract class AbstractClass { abstract public function test(); } class Son extends AbstractClass{ public function test(){ echo \"test\"; } } 2.对象接口 使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。 使用接口（interface）定义的类，和定义一个标准类一样，不过所有的方法都必须是空的。（不可定义属性） 接口的所有方法都必须是公有的。 使用 implements 关键字来实现一个接口。可以一次性实现多个接口。实现多个接口时，方法不能重名。 接口可以继承，使用 extends 关键字。 类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。 foo1(); $obj->foo2(); $obj->foo3(); 3.trait 自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。 trait 可以让单继承的语言准备进行代码复用，避免传统多继承带来的问题。 sayHello(); echo 'World'; } } $obj = new world(); $obj->sayHelloWorld(); // Hello World 从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。 即：当前类 > trait > 被继承的类 sayHello(); ?> 多个 trait sayHello(); $o->sayWorld(); $o->sayExclamationMark(); ?> 如果多个trait中。都有同名的方法，则会产生冲突，冲突会产生一个致命的错误。 可以使用 insteadof 来指明当产生冲突时，使用哪一个。 as 操作符可以 为某个方法引入别名 smallTalk(); // b $obj->bigTalk(); // A $obj->talk(); // B 使用 as 语法还可以用来调整方法的访问控制。 smallTalk(); // 报错 $obj->bigTalk(); $obj->talk(); 使用 trait 来组成 trait sayHello(); $obj->sayWorld(); trait 的抽象方法、静态成员、属性 hello; } } class MyHelloWorld{ use HelloWorld; } $obj = new MyHelloWorld(); $obj->sayHello(); $obj->sayWorld(); 4.匿名类 php 7 之后支持匿名类，匿名类很有用，可以创建一次性的简单对象。 $a = new class{ public function say(){ echo 'Hello'; } }; $a->say(); // Hello 匿名类被嵌套进普通 Class 后，不能访问这个外部类（Outer class）的 private（私有）、protected（受保护）方法或者属性。 为了访问外部类（Outer class）protected 属性或方法，匿名类可以 extend（扩展）此外部类。 为了使用外部类（Outer class）的 private 属性，必须通过构造器传进来： class Outer { private $prop = 1; protected $prop2 = 2; protected function func1() { return 3; } public function func2() { return new class($this->prop) extends Outer { private $prop3; public function __construct($prop) { $this->prop3 = $prop; } public function func3() { return $this->prop2 + $this->prop3 + $this->func1(); // 2+1+3 } }; } } echo (new Outer)->func2()->func3(); // 6 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/08.类与对象3.html":{"url":"PHP-基础知识/08.类与对象3.html","title":"08.类与对象3","keywords":"","body":"08.类与对象3 1.重载与重写 重写是指覆盖原方法，一般用于子类继承父类重写父类方法。 PHP 提供的“重载”是动态的“创建”类的属性和方法。通过使用魔术方法来实现。 当调用当前环境下未定义的属性和方法是，则会调用魔术方法。 在给不可访问属性赋值时，__set() 会被调用。 读取不可访问属性的值时，__get() 会被调用。 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问属性调用 unset() 时，__unset() 会被调用。 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 $name; } public function __set($name,$value){ $this->$name=$value; } public function __isset($name){ echo \"isset $name\".PHP_EOL; } public function __unset($name){ echo \"unset $name\".PHP_EOL; } public function __call($name,$args){ $args = implode(',', $args); echo \"call $name ,args is {$args}\".PHP_EOL; } public static function __callStatic($name,$args){ $args = implode(',', $args); echo \"call static $name ,args is {$args}\".PHP_EOL; } } $obj = new demo(); $obj->a = 'b'; echo $obj->a.PHP_EOL; // b isset($obj->a); // isset a unset($obj->a); // unset a $obj->say('Hello','World'); // call say ,args is Hello,World demo::staticSay('World','World'); // call static staticSay ,args is World,World 2.多态 统一操作，作用于不同对象，得到不同的结果。如数据库操作，$db->query(); 可以是 mysql 的操作，也可以是redis 的 query(); } run(new mysql()); // query mysql run(new redis()); // query redis 3.遍历对象 遍历对象可以使用foreach遍历可见属性。或者实现iterator接口 $v) { echo $key.\"=>\".$v.PHP_EOL; } // var1=>value 1 // var2=>value 2 // var3=>value 3 4.魔术方法 __construct 初始化调用 __desturct 对象销毁时调用 __call 访问一个不存在的方法的时候调用 __callStatic 访问一个不存在的静态方法调用 __get() 访问一个不存在的属性调用 __set() 修改一个不存在的属性调用 __isset() 使用 isset 判断一个高属性的时候调用 __toString() 当一个对象以一个字符串返回时候触发调用 __invoke() 当把一个对象当函数去调用的时候触发 __sleep() 当使用 serialize() 时调用 __wakeup() 当使用 unserialize() 时调用 server]; } public function __wakeup(){ return $this->server; } } $c = new MyClass(); $c(5); // int(5) var_dump($d = serialize($c)); // string(44) \"O:7:\"MyClass\":1:{s:6:\"server\";s:6:\"server\";}\" var_dump(unserialize($d)); //object(MyClass)#2 (1) { // [\"server\"]=> // string(6) \"server\" // } 5.Final 关键字 被 final 修饰的类不能被继承。 如果一个类中某个方法被 final ，这个类不能被重写。 final 不能修饰属性。 6.对象的复制和比较 对象的复制通过 clone 关键字来完成。这将会调用 clone() 方法。对象中的 clone() 方法不能被直接调用 当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。 当复制完成时，如果定义了 clone() 方法，则新创建的对象（复制生成的对象）中的 clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 a = 'b'; } public function say(){ echo $this->a.PHP_EOL; } } $a = new MyClass(); $b = clone $a; $a->say(); // a $b->say(); // b 当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。 而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象） 7.类型约束 函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组 query(); } } $obj = new demo(); $obj->run(new mysql()); // query mysql $obj->run(new redis()); // query redis 8.静态绑定 self 调用的方法是所定义的类所定义的方法。 static 调用的方法是调用类的方法。 9.对象和引用 PHP 的引用是别名，就是两个不同的变量名字指向相同的内容。在 PHP 5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。 当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。 $b->foo = 2; echo $a->foo.\"\\n\"; Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/09.命名空间.html":{"url":"PHP-基础知识/09.命名空间.html","title":"09.命名空间","keywords":"","body":"09.命名空间 命名空间简单来说就是为了解决命名重复而造成的系统冲突。其思想来源于文件路径，\"同一路径下不能存在相同名称的文件\"。 如 www/a、www/b 可以同时存在，www/a/c、www/b/c 也可以同时存在。 1.定义命名空间 命名空间由关键字 namespace 定义。 其必须在程序脚本的第一条语句，否则会报致命错误。除 declare 之外。 子命名空间,中间由 \\ 隔开 2.同一文件定义多个命名空间 3.命名空间基础：命名空间与路径类似，分为非限定名称、限定名称、完全限定名称。 非限定名称，不加前缀的名称，如 $a = new foo(), foo::staticmethod()。如果当前命名空间是 currentnamespace，则 foo 就会被解析成 currentnamespace\\foo。 限定名称，包含前缀的名称，如 $a = new subnamespace\\foo(),或 subnamespace\\foo::staticmethod()。如果当前命名空间为 currentnamespace，则会被解析为 currentnamespace\\subnamespace\\foo。 完全限定名称，如 $a = new currentnamespace\\subnamespace\\foo(), currentnamespace\\subnamespace\\foo::staticmethod()。 // file1 // file2 // file3 4.namespace 与 NAMESPACE 常量 NAMESPACE 表示当前的命名空间，如果在全局中，则返回一个空字符串。 关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。 5.别名与导入 使用 use 关键字来导入命名空间 使用 as 关键字来给命名空间取别名，可以给类、接口、命名空间使用别名。 6.全局命名空间 如果没有定义任何命名空间，则为全局空间，调用时在前面加斜杠 (\\) 7.名称规则解析 类名称总是会解析到当前命名空间中，如果不存在则需要使用完全限定命名空间。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "},"PHP-基础知识/10.PHP-FPM 与 Nginx.html":{"url":"PHP-基础知识/10.PHP-FPM 与 Nginx.html","title":"10.PHP-FPM 与 Nginx","keywords":"","body":"10.PHP-FPM 与 Nginx 1.基础 静态数据 在整个网站架构中，web server 只是一个内容分发者。如客户端请求的是 index.html 时，web server 会在文件系统中找到这个 index.html 文件，发送给浏览器，这里分发的事静态数据。 动态数据 如果请求的是 index.php 文件，那么 web server 会将客户端的请求数据，通过 CGI 协议转发给 PHP 解析器来处理。 当 web server 收到 index.php 请求后，会启动相应的 CGI 程序，CGI 程序会找到 PHP 的配置文件 php.ini 进行程序的初始化，然后处理请求，再以规定的 CGI 的规定转换为相应的格式返回给 web server，最后返回给客户端。这就是一个完整的访问流程。 2.几个概念： Web Application：指 Apache 、Nginx Web Server：指 PHP、Java 等。 CGI：通用网关接口（Common Gateway Interface），是 Web Server 和 Web Application 之间的一种数据交换协议。 CGI 就相当于两个不同国家的人用来交流的翻译器。Web Server 将数据（url，查询字符串，POST 数据，HTTP header 等）通过标准的输入传递给 Web Application ， Web Application 根据配置文件初始化后(如 PHP 解析器会先根据 php.ini 文件进行初始化)，再处理数据，通过标准的输出返回给 Web Server。 但是 CGI 有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的 fork-and-execute 模式，这样一在大规模并发下，就死翘翘了。 FastCGI：同 CGI，是一种通信协议，在 CGI 的效率上做了优化。 做了哪些优化呢，“PHP 解析器会先根据 php.ini 文件进行初始化” 这里。每次执行程序都会执行一次这个操作，随着 web 的兴起，高并发是常态，这样低效且浪费资源的方式，导致处理每个请求都耗费很长时间。 FastCGI 会先启动一个 master，解析配置文件，初始化执行环境，然后在启动多个 worker。当有新请求过来时，通过 master 会传递给 worker 然后立即执行下一给请求，这样就避免了重复劳动，提高了效率。 当 worker 不够用可以根据配置提前启动几个 worker 等着。当 worker 多余时，也会停掉一些，这样就提高了性能，节约了资源。 FastCGI 是一个常驻性版本的 CGI，它可以一直执行，不用每次都花费时间去 fork。 FastCGI 接口方式采用 C/S 的架构，可以将 Web Server 和 Web Application 分开，同时在服务器上启动一个或多个守护进程。当有请求过来时，直接发送给 FastCGI 进程处理，将结果返回给浏览器。这种方式可以让 Web Server 专心处理静态数据或者将动态数据传给 Web Application ,很大程度上提高了性能。 PHP-CGI：是 PHP（Web Application）对 Web Server 提供的 CGI 的接口程序。 官方出品的 CGI 程序。但是性能太差。 在修改了 php.ini 文件后，必须重启 PHP-CGI 才能让新 php.ini 生效。无法平滑重启 直接杀死 PHP-CGI 后程序将无法执行。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 的接口程序。还提供了相对智能的任务管理。 PHP-FPM 是 FastCGI 的具体实现，负责管理一个进程池，处理 Web Server 的请求。 是一个 PHP 进程管理器，包含 master 和 worker 两种进程。master 进程只有一个，负责监听端口，接收来自服务器的请求，而 worker 根据配置可以有多个，每个进程内部嵌入了一个 php 解释器，是 PHP 代码真正执行的地方。 具体步骤如下： FPM 的 master 接受请求 master 根据配置指定给 worker 进行请求处理，如没有可用 worker 则返回错误，nginx 报 502。 worker 请求超时，返回错误，nginx 报 504。 请求处理结束，返回结果。 当修改了 php.ini 之后，PHP-CGI 程序是无法重启的。所以 PHP-FPM 的做法是当旧的进程处理完旧请求后，杀死。通过启动新的 worker 进程来启用新的配置，这样实现平滑重启。 3.nginx Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器。提供了很多协议，如 HTTP，当然也有与 FPM 相关的 FastCGI 协议。Nginx 提供了 FastCGI 模块来将 HTTP 请求映射为对应的 FastCGI 请求。 Nginx 的 FastCGI 模块提供了 fastcgi_param 指令，主要处理参数的映射关系。这些都是基本不变的，会单独放在一个文件中。 $ cat /usr/local/nginx/conf/fastcgi.conf fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param REQUEST_URI $request_uri; fastcgi_param DOCUMENT_URI $document_uri; fastcgi_param DOCUMENT_ROOT $document_root; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param REQUEST_SCHEME $scheme; fastcgi_param HTTPS $https if_not_empty; fastcgi_param GATEWAY_INTERFACE CGI/1.1; fastcgi_param SERVER_SOFTWARE nginx/$nginx_version; fastcgi_param REMOTE_ADDR $remote_addr; fastcgi_param REMOTE_PORT $remote_port; fastcgi_param SERVER_ADDR $server_addr; fastcgi_param SERVER_PORT $server_port; fastcgi_param SERVER_NAME $server_name; 在 Nginx 的服务器配置中，最重要的 fastcgi_pass 指令，这个指令用于监听 FPM 进程地址，Nginx 会把所有的 php 请求 翻译成 FastCGI 请求再发送给这个地址。下面一个服务器配置实例。 server { listen 80; server_name test.me; root /usr/local/web/myproject/public; index index.php index.html index.htm; access_log /usr/local/nginx/logs/test-access.log; error_log /usr/local/nginx/logs/test-error.log; location / { try_files $uri $uri/ /index.php?$query_string; } location ~\\.php$ { include fastcgi_params; fastcgi_param SCRIPT_FILENAME /usr/local/web/myproject/public/$fastcgi_script_name; fastcgi_pass unix:/usr/local/php/var/run/php-fpm.sock; fastcgi_index index.php; } } 在这个配置文件中，我们新建了一个虚拟主机，监听端口 80，项目根目录为 /usr/local/web/myproject/public。然后通过 location 指令，将所有以 .php 结尾的请求都交给 FastCGI 模块处理。从而把所有的PHP请求都交给了FPM处理，从而完成Nginx到FPM的闭环。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-20 18:14:16 "}}