{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 12:15:05 "},"MySQL/01.初识 MySQL.html":{"url":"MySQL/01.初识 MySQL.html","title":"01.初识 MySQL","keywords":"","body":"01.初识 MySQL 1.bin 目录下的可执行文件 我的 macOS 上路径为 /usr/local/Cellar/mysql/8.0.17/bin/。 mysqld mysqld 就代表着 Mysql 的服务器程序，运行这个程序就可以直接启动一个服务器进程。但是不常用。 mysqld_safe mysqld_safe 是一个启动脚本，它会间接启动 mysqld，并启动一个监控进程，当 mysqld 挂了的时候，可以帮助重启它。mysqld_safe 还会产生一个错误日志，方便查询错误。 mysql.server mysql.server 是一个启动脚本，会间接调用 mysqld_safe。它其实是一个链接，链接到 mysql.server -> ../support-files/mysql.server。 # 启动 mysql.server mysql.server start # 关闭 mysql.server stop mysqld.multi 可以在同一台计算机上开多个服务器实例，也就是运行多个 mysql 进程。可以对每个进程的启动和停止做监控。 2.启动 mysql mysql -h主机名 -u用户名 -P端口号 -p密码 # 不要明文在 -p 后面写密码，而是通过回车来输入密码 Enter password: 3.服务器处理客户端请求 客户端请求服务器流程 连接管理 客户端进程通过 TCP/IP、Unix 嵌套字等方式来与服务器进程建立连接。每当有一个客户端进程连接到服务器时，服务器进程会创建一个线程来与客户端交互，当客户端退出时，服务器端不会立即销毁该线程，而是把他缓存起来，等下个客户端连接时，把这个缓存的线程分配给新客户端，这样避免了频繁创建和销毁线程的作用，节省了服务器资源。 这里的连接方式，和 PHP-FPM 很像，不过 PHP-FPM 是通过一个 master 进程来管理 多个 worker 进程，当服务器有请求时，master 会把请求分发给其中一个 worker 来处理，处理完之后返回给服务器。并不会销毁 worker 进程，也避免了平凡创建和销毁进程的作用，借阅服务器资源 解析与优化 执行一条 sql 语句，mysql 会通过查询缓存、语法解析、查询优化三个方面来处理。 查询缓存 即当一个客户端执行完一条 sql 语句后，另一个客户端再执行完全相同的 sql 语句时，mysql 不会重复执行，它会把第一次查询的内容存入缓存，第二次查询的时候直接从缓存中取出结果。 值得注意的事，首先只有当查询语句完全相同时（包括空格，注释，大小写），mysql 才会命中缓存。还有请求的是系统表和系统函数都不会被缓存。 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存⽽造成⼀些开销，⽐如每次都要去查 询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不 推荐使⽤查询缓存，并在MySQL 8.0中删除。 语法解析 当查询缓存没有命中，mysql 服务器就会将传过来的 sql 语句进行分析、判断语法是否正确，然后从⽂本中将要查询的表、各种查询条件 都提取出来放到 MySQL 服务器内部使⽤的⼀些数据结构上来。 查询优化 语法解析之后，服务器得到了需要的信息，如查询哪张表，哪些字段，什么条件，由于我们自己写的 sql 语句执行效率可能并不高，所以 mysql 的优化程序会做一些优化，如外连接转换为内连接、表达式简化、⼦查询转为连接等。 存储引擎 mysql 把数据的存储和操作都封装到了一个叫「存储引擎」的模块中。存储引擎封装着如物理上如何表示记录，如何把数据写入物理存储器，使用什么方法读取出来等等。 最常用的存储引擎是 InnoDB，MyISAM 。 InnoDB，行锁，支持事务与分布式事务，事务回滚。不支持全文索引 FULLTEXT。写慢，清空表时是一行行删除。 MyISAM，表索，不支持事务，支持全文索引，写快。 操作 创建表指定存储引擎 create table 表名( 建表语句 )ENGINE = 存储引擎名称 修改表引擎 ALTER TABLE 表名 ENGINE = 存储引擎名称 查看引擎 SHOW CREATE TABLE 表名 4.启动选项和配置文件 在命令⾏上使⽤选项 在启动时，可以增加选项来配置参数，如启动 mysql 时的 -h 选择主机名。 在启动时，在选项名加 -- 前缀，如果选项名是多个单词可以用下划线 _ 或者横杠 - 来链接。查询有哪些选项可以通过 --help 来查询。 mysqld --skip_networking # 这两种写法等价 mysqld --skip-networking # 指定默认引擎为 MyISAM mysqld --default-storage-engine=MyISAM 选项有长形式和短形式，「--选项名」为长形式，「-字母」为短形式。 --host、-h 主机名 --user、-u 用户名 --password、-p 密码 --port、-P 端⼝ 当使用 mysqld_safe 启动服务器时，对于传的启动选项 mysqld_safe 并不会处理，会传给 mysqld 来处理 # mysqld_server 不会处理，将会把 --skip-networking 传递给 mysqld 处理 mysqld_server --skip-networking 配置文件 在类 UNIX 操作系统中， MySQL 会按照下列路径来寻找配置⽂件： 路径名 备注 /etc/my.cnf /etc/mysql/my.cnf SYSCONFDIR/my.cnf $MYSQL_HOME/my.cnf 特定于服务器的选项（仅限服务器） defaults-extra-file 命令⾏指定的额外配置⽂件路径 ~/.my.cnf ⽤户特定选项 ~/.mylogin.cnf 用户特定的登录路径选项（仅限客户端） 配置文件下面，分别有 server、mysqld、mysqld_safe、client、mysql、mysqladmin 这几个组名。而不同的启动命令，能读取的组名下的配置是不一样的。 |启动命令|类别|能读取的组| |:--:|:--:|:--:| |mysqld |启动服务器 |[mysqld]、[server]| |mysqld_safe |启动服务器 |[mysqld]、[server]、[mysqld_safe]| |mysql.server| 启动服务器 |[mysqld]、[server]、[mysql.server]| |mysql |启动客户端 |[mysql]、[client]| |mysqladmin |启动客户端 |[mysqladmin]、[client]| |mysqldump |启动客户端 |[mysqldump]、[client]| 配置文件的优先级 多个配置文件设置了相同的启动选项，则以最后一个配置文件中的为准 比如在 ~/.my.cnf 和 /etc/my.cnf 都设置了 default-storage-engine ，前者是 InnoDB，后者是 MyISAM，因为~/.my.cnf比/etc/my.cnf顺序靠后，所以如果两个配置文件中出现相同的启动选项，以~/.my.cnf中的为准，所以MySQL服务器程序启动之后，default-storage-engine的值就是MyISAM。 同一个配置文件，多个组设置了相同的启动选项，则以最后一个出现的组为准 比方说例子中default-storage-engine既出现在[mysqld]组也出现在[server]组，因为[mysqld]组在[server]组后边，就以[mysqld]组中的配置项为准。 如果同一个启动选项，同时出现在配置文件和命令行中，则以命令行为准 系统变量 大部分系统变量，可以在服务器运行的过程中进行动态修改而不用重启服务器。 通过 SET [GLOBAL 全局|SESSION 会话] 系统变量名 = 值; 设置系统变量 全局变量影响整个服务器操作，会话变量影响单个会话的操作。 # 设置全局系统变量，两种写法等价 set global default_storage_engine=InnoDB; set @@global.default_storage_engine=InnoDB; # 设置会话变量，三种写法等价 SET SESSION default_storage_engine = MyISAM; SET @@SESSION.default_storage_engine = MyISAM; SET default_storage_engine = MyISAM; 通过 SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式]; 来查询。 # 查询全局系统变量中有 default 的系统变量 show global variables like \"%default%\"; # 查询全局系统变量中客户端最大连接数 show global variables like \"max_connections\"; # 查询会话系统变量中系统默认引擎 show session variables like \"default_storage_engine\"; 注意： 1. 并不是所有系统变量都具有 GLOBAL 和 SESSION 的作用范围。 有一些只具有 gloabl 作用范围，如 max_connections 。 有一些只具有 session 作用范围，如 insert_id，表示插入时 auto_increment 的值。 有一些两个作用范围都有的，如 default_storage_engine。 2. 有一些只读的系统变量，不能设置 如 version，查看系统版本。 状态变量 状态变量表示服务器运行状况，这些是由服务器自己设置，所以不能修改。与系统变量类似，状态变量也分为全局和会话两种。 通过 SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式]; 查询。 # 查询当前线程相关状态 show session status like \"thread%\"; 结果 +-------------------+-------+ | Variable_name | Value | +-------------------+-------+ | Threads_cached | 0 | | Threads_connected | 1 | | Threads_created | 1 | | Threads_running | 1 | +-------------------+-------+ 4 rows in set (0.00 sec) Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"MySQL/02.字符集与比较规则.html":{"url":"MySQL/02.字符集与比较规则.html","title":"02.字符集与比较规则","keywords":"","body":"02.字符集与比较规则 1. 字符集简介 字符集就是建立字符与计算机使用的二进制之间的映射关系。 例如，采用1个字节编码一个字符的形式（一个字节有 8 位二进制），字符和字节的映射关系如下： 'a' -> 00000001 (十六进制：0x01) 'b' -> 00000010 (十六进制：0x02) 'A' -> 00000011 (十六进制：0x03) 'B' -> 00000100 (十六进制：0x04) 2. 比较规则简介 比较规则，就是如何比较两个字符的大小指定的规则。比方说字符'a'的编码为0x01，字符'b'的编码为0x02，所以'a'小于'b'。 比较规则有多种，满足不同需求。 比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。 一些重要的字符集 ASCII 字符集 共有 128 个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才 128 个，所以是一个字节。 ISO 8859-1 字符集 共有 256 个字符，在 ASCII 上扩充了128个西欧常用字符(包括德法两国的字母)。也是一个字节。 GB2312字符集 收录了汉字、拉丁字母、希腊字母、平假名片假名、俄语西里尔字母。兼容 ASCII 字符集。 如果该字符在 ASCII 字符集中，则采用 1 字节 否则采用 2 字节 GBK 字符集 在 GB2312 字符集上做了扩充。 UTF8 字符集 收录了地球上所有的字符，而且还在扩充。 Mysql 中的字符集和比较规则 MySQL中的 utf8 和 utf8mb4 utf8 = utf8mb3 : 阉割过的 utf8 字符集，只使用 1-3 个字节表示字符。 utf8mb4：正宗的 utf8 字符集，使用 1-4 个字节表示字符。 字符集的查看 通过 SHOW (CHARACTER SET|CHARSET) [LIKE 匹配模式]; 来查看。 mysql> SHOW CHARSET; +----------+---------------------------------+---------------------+--------+ | Charset | Description | Default collation | Maxlen | +----------+---------------------------------+---------------------+--------+ | big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 | ... | latin1 | cp1252 West European | latin1_swedish_ci | 1 | | latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 | ... | ascii | US ASCII | ascii_general_ci | 1 | ... | gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 | ... | gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 | | latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 | ... | utf8 | UTF-8 Unicode | utf8_general_ci | 3 | | ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 | ... | latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 | | utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 | | utf16 | UTF-16 Unicode | utf16_general_ci | 4 | | utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 | ... | utf32 | UTF-32 Unicode | utf32_general_ci | 4 | | binary | Binary pseudo charset | binary | 1 | ... | gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 | +----------+---------------------------------+---------------------+--------+ 41 rows in set (0.01 sec) mysql 总共有 41 个字符集，其中 default collation 是默认比较规则，maxlen 表示一个字节的最大字节长度。 需要记住 |字符集名称 |Maxlen| |--|--| |ascii |1| |latin1| 1| |gb2312| 2| |gbk |2| |utf8| 3| |utf8mb4| 4| 查看比较规则 通过 SHOW COLLATION [LIKE 匹配模式]; 来查看 mysql> SHOW COLLATION LIKE 'utf8\\_%'; +--------------------------+---------+-----+---------+----------+---------+ | Collation | Charset | Id | Default | Compiled | Sortlen | +--------------------------+---------+-----+---------+----------+---------+ | utf8_general_ci | utf8 | 33 | Yes | Yes | 1 | | utf8_bin | utf8 | 83 | | Yes | 1 | | utf8_unicode_ci | utf8 | 192 | | Yes | 8 | | utf8_icelandic_ci | utf8 | 193 | | Yes | 8 | | utf8_latvian_ci | utf8 | 194 | | Yes | 8 | | utf8_romanian_ci | utf8 | 195 | | Yes | 8 | | utf8_slovenian_ci | utf8 | 196 | | Yes | 8 | | utf8_polish_ci | utf8 | 197 | | Yes | 8 | | utf8_estonian_ci | utf8 | 198 | | Yes | 8 | | utf8_spanish_ci | utf8 | 199 | | Yes | 8 | | utf8_swedish_ci | utf8 | 200 | | Yes | 8 | | utf8_turkish_ci | utf8 | 201 | | Yes | 8 | | utf8_czech_ci | utf8 | 202 | | Yes | 8 | | utf8_danish_ci | utf8 | 203 | | Yes | 8 | | utf8_lithuanian_ci | utf8 | 204 | | Yes | 8 | | utf8_slovak_ci | utf8 | 205 | | Yes | 8 | | utf8_spanish2_ci | utf8 | 206 | | Yes | 8 | | utf8_roman_ci | utf8 | 207 | | Yes | 8 | | utf8_persian_ci | utf8 | 208 | | Yes | 8 | | utf8_esperanto_ci | utf8 | 209 | | Yes | 8 | | utf8_hungarian_ci | utf8 | 210 | | Yes | 8 | | utf8_sinhala_ci | utf8 | 211 | | Yes | 8 | | utf8_german2_ci | utf8 | 212 | | Yes | 8 | | utf8_croatian_ci | utf8 | 213 | | Yes | 8 | | utf8_unicode_520_ci | utf8 | 214 | | Yes | 8 | | utf8_vietnamese_ci | utf8 | 215 | | Yes | 8 | | utf8_general_mysql500_ci | utf8 | 223 | | Yes | 1 | +--------------------------+---------+-----+---------+----------+---------+ 27 rows in set (0.00 sec) 可以看到这是 utf8 的比较规则，有几个特点 都以 utf8_ 开头 后面紧跟的是比较规则主要作用于哪种语言，比如utf8_polish_ci表示以波兰语的规则比较，utf8_spanish_ci是以西班牙语的规则比较，utf8_general_ci是一种通用的比较规则。 后缀表示是否区分语言中的重音、大小写等： |后缀 |英文释义 |描述| |--|--|--| |_ai |accent insensitive |不区分重音| |_as |accent sensitive |区分重音| |_ci |case insensitive |不区分大小写| |_cs |case sensitive |区分大小写| |_bin |binary |以二进制方式比较| 比较规则的应用 比较规则共有 4 个级别： 服务器级别 character_set_server 服务器级别的字符集 collation_server 服务器级别的比较规则 这两个值在配置文件中修改。 数据库级别 character_set_database 当前数据库的字符集 collation_database 当前数据库的比较规则 CREATE DATABASE 数据库名 [[DEFAULT] CHARACTER SET 字符集名称] [[DEFAULT] COLLATE 比较规则名称]; ALTER DATABASE 数据库名 [[DEFAULT] CHARACTER SET 字符集名称] [[DEFAULT] COLLATE 比较规则名称]; 表级别 CREATE TABLE 表名 (列的信息) [[DEFAULT] CHARACTER SET 字符集名称] [COLLATE 比较规则名称]] ALTER TABLE 表名 [[DEFAULT] CHARACTER SET 字符集名称] [COLLATE 比较规则名称] 行级别 REATE TABLE 表名( 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称], 其他列... ); ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称]; 只修改字符集或比较规则： 只修改字符集，比较规则变为修改后的字符集默认的比较规则。 只修改比较规则，字符集变为修改后的比较规则对应的字符集。 字符集与比较规则的关系： 如果创建时没有显示指定字符集和比较关系，则默认使用上一级的字符集与比较规则。行->表->库->服务器。 # 客户端和服务器中的字符集 如果客户端与服务器中的编码规则不一致，则会导致“乱码”。 客户端请求服务器，服务器处理并返回给客户端，这个过程中伴随多次字符集的转换。用到了三个系统变量 |系统变量 |描述| |--|--| |character_set_client |服务器解码请求时使用的字符集| |character_set_connection |服务器运行过程中使用的字符集| |character_set_results |服务器向客户端返回数据时使用的字符集| 服务器认为客户端传的请求是以 character_set_client 来编码的，如果不一致，则无法请求。 服务器把得到的结果通过 character_set_results 来编码回传给客户端，如果不一致则乱码。 所以，为了保证一致性，这三个系统变量通常统一设置成一个字符集。 SET character_set_client = 字符集名; SET character_set_connection = 字符集名; SET character_set_results = 字符集名; Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/01.类型.html":{"url":"PHP-基础知识/01.类型.html","title":"01.类型","keywords":"","body":"01.类型 php 开启 '' 短标签：在 php.ini 中找到 short_open_tag 改为 true。（不建议使用） 如果文本为纯 PHP 代码，则最好删除 PHP 结束标记，这样可以防止意外加入的空格和换行符，会导致 PHP 输出本无意输出的空格。 php 的 ?> 结尾自带一个分号，如 合法。 1、类型 PHP 支持 9 种原始数据类型 基本类型，标量 整形 integer 字符串 string 浮点型 float 布尔型 boolean复合类型 对象 object 数组 array 可调用 callback其他 资源 resource NULL 其类型判断可通过：is_integer , is_string() , is_float() , is_bool() , is_array() , is_object() , is_resource() , is_null() , is_numeric() , is_scalar() 判断是否是标量 1.1 Boolean 布尔类型 $bool = True; // 不区分大小写 其他类型转换 当其他类型转换为 Boolean 时，以下 7 个会被认为是 FALSE： 布尔 FALSE 本身 整型 0 浮点型 0.0 空字符串 '' 以及 '0' 不包含任何元素的空数组 [] 特殊类型 NULL 从空标记生成的 SimpleXML 对象。 1.2 Integer 整型 32 位系统中范围为 -2^31-1 ~ 2^31-1 64 位系统中范围为 -2*63-1 ~ 2^63-1 123 -123 0123 #八进制 0x123 #十六进制 当给定的数超过范围时，php 会自动将其变为 浮点型（Float） 。同样通过计算的超过范围也会返回 浮点型（Float） 。做除法运算时，除不尽的也会变成 浮点型（Float） 。 PHP 7.0.0 起，NaN 和 Infinity 在转换成 integer 时，不再是 undefined 或者依赖于平台，而是都会变成零。 其他类型转换 资源类型 Resource 将返回 php 运行时 resource 分配的唯一资源号 布尔型 Boolean false=0，true=1 浮点型 Float 通常情况下是向下取整，但是由于精度问题可能造成无法预估的情况 echo (int) ( (0.1+0.7) * 10 ); // 显示 7! 字符串 String 如果字符串中没有包含 ','，'E'或'e'，该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 'e' 或 'E' 后面跟着一个或多个数字构成。 1.3 Float 浮点型 浮点数精度有限，取决于系统。永远不要相信浮点数最后一位。也不要直接比较两个浮点数，如需要请使用精度函数 bc。 字符串转换为数值 1.4 String 字符串 字符串有 4 种表示方法 单引号，单引号中变量不被解析。如果要表达单引号本身需要加反斜线\\。 $a = 'abc'; $b = '$a';//$a $c = \"$a\"; //abc 双引号，双引号中的变量以及特殊字符会被解析。\\n 换行（ASCII 字符集中的 LF 或 0x0A (10)） \\r 回车（ASCII 字符集中的 CR 或 0x0D (13)） \\t 水平制表符（ASCII 字符集中的 HT 或 0x09 (9)） \\\\ 反斜线 \\$ 美元标记 \\\" 双引号 heredoc 结构是一种提供一个开始标记和一个结束标记。方便书写大段的字符串。结束标记必须顶格写。类似双引号。单引号不转义。变量解析 foo = 'Foo'; $this->bar = array('Bar1', 'Bar2', 'Bar3'); } } $foo = new foo(); $name = 'MyName'; echo foo. Now, I am printing some {$foo->bar[1]}. This should print a capital 'A': \\x41 EOT; // 输出 My name is \"MyName\". I am printing some Foo. Now, I am printing some Bar2. This should print a capital 'A': A Nowdoc 结构是类似于单引号字符串的。Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中不进行解析操作 nowdoc前需要加上单引号。 string中的字符可以通过一个从 0 开始的下标，用类似 Array 结构中的方括号包含对应的数字来访问和修改，也可以通过花括号{}。 $a = 'start'; echo $a[0]; // 输出 s echo $a{0}; // 输出 s 字符串的连接使用 . 来完成。 $a = 'a'; $b = 'b'; echo $a.$b; // ab 复杂（花括号）语法，可以在字符串中使用复杂表达式。其方式为在 string 中将表达式通过 {}（花括号）括起来。变量$符号必须紧挨{（左花括号）。 $great = 'fantastic'; echo \"This is {$great}\"; // 有效 echo \"This is { $great}\"; // 无效 echo \"This is ${great}\"; // 有效 echo \"This square is {$square->width}00 centimeters broad.\"; // 有效 echo \"This works: {$arr['key']}\";// 有效，只有通过花括号语法才能正确解析带引号的键名 echo \"This works: {$arr[4][3]}\"; // 有效 echo \"This works: {$arr['foo'][3]}\"; // 有效，当在字符串中使用多重数组时，一定要用括号将它括起来 // 有效 echo \"This works: \" . $arr['foo'][3]; echo \"This works too: {$obj->values[3]->name}\"; echo \"This is the value of the var named $name: {${$name}}\"; echo \"This is the value of the var named by the return value of getName(): {${getName()}}\"; echo \"This is the value of the var named by the return value of \\$object->getName(): {${$object->getName()}}\"; 转换为字符串 boolean 的 true 会被转换为 string \"1\"，而 false 会被转换为 string ‘’。 整数和浮点数就直接被装换为字面的 string。 array 类型会被转换为 string “Array”。 object 类型会被转换为 string “Object”。 资源 resource 总会被转变成 \"Resource id #1\" 这种结构的字符串。 NULL 总是被转变成空字符串。 1.5 Array 数组 PHP 中的数组是一个有序映射。映射是一种把 values 映射到 keys 的类型。 $a = array(1,2,3); // 索引数组 $b = [ 'a'=>'abc', 'd'=>'def', ]; // 简写 php5.4+，关联数组 键名 包含有合法整型值的字符串会被转换为整型。例如键名 \"8\" 实际会被储存为 8。但是 \"08\" 则不会强制转换，因为其不是一个合法的十进制数值。 浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。 布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。 Null 会被转换为空字符串，即键名 null 实际会被储存为 \"\"。 数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。 1.6 Object 对象 通过 new 来实例化对象 class a{} $obj = new a(); 1.7 Resource 资源 资源类型是保持外部的一个引用。如数据库的链接，文件的句柄等。 $fp = fopen(\"./a.log\");//resource 1.8 Null Null 表示一个变量没有值。Null 类型唯一的值就是 Null。 3 种情况下会被认为是 Null 变量没有赋值 变量赋值 Null 变量被 unset();$a = null // null $b;//var_dump($b); null $c = 1; unset($c);//var_dump($c); null 1.9 Callback 类型 一些函数如 call_user_func() 或 usort() 可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。 // An example callback function function my_callback_function() { echo 'hello world!'; } // An example callback method class MyClass { static function myCallbackMethod() { echo 'Hello World!'; } } // Type 1: Simple callback call_user_func('my_callback_function'); // Type 2: Static class method call call_user_func(array('MyClass', 'myCallbackMethod')); // Type 3: Object method call $obj = new MyClass(); call_user_func(array($obj, 'myCallbackMethod')); // Type 4: Static class method call (As of PHP 5.2.3) call_user_func('MyClass::myCallbackMethod'); Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/02.变量与常量.html":{"url":"PHP-基础知识/02.变量与常量.html","title":"02.变量与常量","keywords":"","body":"02.变量与常量 php 变量通常以美元 $ 符号开头，以字母、下划线开头，后面跟任意字母、数字、下滑线。 php 的变量大小写敏感，通常以小驼峰或单词以下划线隔开来命名。如 $productSku 或 $product_sku $this 是一个特殊的变量，不能定位成 this 变量。 $a; // 合法 $_a; // 合法 $2a; // 非法 1. 变量的引用赋值 通过给变量钱加 & 来赋值。只能引用有值的变量。 $a = 4; $b = &$a; $b = 5; echo $a; // 5 echo $b; // 5 2. 预定义变量 超全局变量：在全部作用域下始终可用的内置变量 超全局变量 解释 $GLOBALS 引用全局作用域中所有的全部变量 $_GET HTTP GET 变量 $_POST HTTP POST 变量 $_REQUREST HTTP Request 变量 $_SERVER 服务器和执行环境信息 $_FIELS 文件上传变量 $_SESSION Session 变量 $_COOKIE Cookie 变量 $_ENV 环境变量 预定义变量 |预定义变量|解释| |:--:|:--:| |$php_errormsg | 前一个错误信息| |$HTTP_RAW_POST_DATA | 原生POST数据| |$http_response_header | HTTP 响应头| |$argc | 传递给脚本的参数数目| |$argv | 传递给脚本的参数数组| 3. 可变变量 变量名称本身是个变量的变量叫可变变量1 超全局变量和 $this 不可用作可变变量。 $a = 'b'; $b = '4'; echo $$a; // 4 4. 变量的作用域 在文件最外层定义的变量是全局变量。 函数内部的变量是局部变量，局部变量只能在函数内访问。 $a = 123; function test(){ echo $a; } echo $a; // 123; test(); // 无输出 在函数内通过 static 修饰的变量，仅在局部函数内存在，当程序作用完之后离开时，静态变量不会消失，等全部程序执行完成后才会销毁。 function test(){ static $a = 0; // 正确 static $a = 1; // 会报错，static 不能重复通过 static 定义。 $a++; echo $a; } test(); // 1 test(); // 2 在函数内部通过 global 修饰函数外部全局变量，可以使全局变量能够作用于局部函数内部 5. 常量 常量是定义之后就不能更改的变量。通常由 define() 函数来定义。常量通常大写，其他命名规则与变量类似。 define('IS_DEBUG',0); 在常量中还有一些系统预定义好的常量。如 PHP_EOL 换行。 8 个魔术常量 常量 解释 LINE 文件中当前行号 FILE 返回包含当前文件名的绝对路径 DIR 返回当前文件所在文件夹的绝对路径（结尾不包含反斜杠/） FUNCTION 返回当前函数的名称 CLASS 返回当前类的名称 TRAIT 返回 trait 的名字 METHOD 返回类的方法名 NAMESPACE 返回命名空间 namespace App; class test{ public function a(){ echo __CLASS__.PHP_EOL; echo __METHOD__.PHP_EOL; echo __NAMESPACE__.PHP_EOL; echo __FUNCTION__.PHP_EOL; } } $obj = new test(); $obj->a(); // 输出 App\\test // App\\test::a // App // a Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/03.运算符.html":{"url":"PHP-基础知识/03.运算符.html","title":"03.运算符","keywords":"","body":"03.运算符 1.运算符优先级 结合方向 运算符 附加信息 无 clone new clone 和 new 左 [ array() 右 \\ 算术运算符 右 ++ -- ~ (int) (float) (string) (array) (object) (bool) @ 类型和递增／递减 无 instanceof 类型 右 ! 逻辑运算符 左 ** / %* 算术运算符 左 + - . 算术运算符和字符串运算符 左 >> 位运算符 无 > >= 比较运算符 无 == != === !== <> 比较运算符 左 & 位运算符和引用 左 ^ 位运算符 左 ｜ 位运算符 左 && 逻辑运算符 左 ｜｜ 逻辑运算符 左 ?? 比较运算符 左 ? : ternary right = += -= =* *= /= .= %= &= ｜= ^= >>=* 赋值运算符 左 and 逻辑运算符 左 xor 逻辑运算符 左 or 逻辑运算符 $a = 5, $b = 5 ?> 2. 算数运算符 $a = 5; $b = 2; echo $a+$b; // 加法 结果：7 echo $a-$b; // 减法 结果：3 echo $a*$b; // 乘法 结果：10 echo $a/$b; // 除法取商 结果：2 echo $a%$b; // 取模 结果：1 echo $a**$b; // 指数乘积 结果：25 // 取模例子 取模正负只看前一个值得正负 echo (5 % 3); // 结果：2 echo (-5 % 3); // 结果：-2 echo (5 % -3); // 结果：2 echo (-5 % -3); // 结果：-2 3.赋值运算符 $b = 4; $a = $b +=5; // $a = $b = ($b+5) a b 都等于 9 $c = 'hello'; $c .= 'world'; // hello world $d = 4; $e = &d; // 引用赋值 $e = 5; // d e 都等于 5 4.位运算符 $a \\&\\ $b And（按位与） 将把 $a 和 $b 中都为 1 的位设为 1。 $a \\｜$b Or（按位或） 将把 $a 和 $b 中任何一个为 1 的位设为 1。 $a ^ $b Xor（按位异或） 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。 ~ $a Not（按位取反） 将 $a 中为 0 的位设为 1，反之亦然。 $a Shift left（左移） 将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。 $a >> $b Shift right（右移） 将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。 5.比较运算符 当比较有字符串时，会把字符串转换为数字来进行比较 $a == $b 等于 TRUE，如果类型转换后 $a 等于 $b。 $a === $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。 $a != $b 不等 TRUE，如果类型转换后 $a 不等于 $b。 $a <> $b 不等 TRUE，如果类型转换后 $a 不等于 $b。 $a !== $b 不全等 TRUE，如果 $a 不等于 $b，或者它们的类型不同。 $a 小与 TRUE，如果 $a 严格小于 $b。 $a > $b 大于 TRUE，如果 $a 严格大于 $b。 $a 小于等于 TRUE，如果 $a 小于或者等于 $b。 $a >= $b 大于等于 TRUE，如果 $a 大于或者等于 $b。 $a $b 太空船运算符（组合比较符） 当$a小于、等于、大于$b时 分别返回一个小于、等于、大于0的integer 值。 PHP7开始提供. $a ?? $b ?? $c NULL 合并操作符 从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL。PHP7开始提供。 echo 1 1; // 0 echo 2 1; // 1 echo 1 2; // -1 echo 'a' 'b'; // -1 echo 'a' 'a'; // 0 echo 'b' 'a'; // 1 echo \"a\" \"aa\"; // -1 echo \"zz\" \"aa\"; // 1 echo [] []; // 0 echo [1, 2, 3] [1, 2, 3]; // 0 echo [1, 2, 3] []; // 1 echo [1, 2, 3] [1, 2, 1]; // 1 echo [1, 2, 3] [1, 2, 4]; // -1 多种类型比较 运算数 1 运算数 2 结果 null 或 string string null 转换为'',再比较 bool 或 null 任何其他类型 null 转换为 false，再比较 object object 除非内部结构相同，否则无法比较。 == 属性和值一样则相等。 === 判断是否为同一对象 string，resource 或 number string，resource 或 number 都转换为数字比较 array array 较少成员的较小。如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较 array 任何其它类型 array 总是更大 object 任何其它类型 object 总是更大 6.错误控制运算符 PHP 支持在表达式前加 @ 。表示忽略这个表达式的可能产生的任何错误 7.执行运算符 PHP 支持一个执行运算符：反引号(`)。PHP 将其作为 shell 命令进行执行，并返回结果。 反引号不能在双引号中执行。 反引号不能再激活了安全模式或者关闭了 shell_exec() 时执行。 ```php $a =ls -al`; echo $a; // 结果 -rw-r--r--@ 1 jupiter.k staff 241684 Mar 18 23:30 a.txt #### 8.递增/递减运算符 ```php $a = 5; $a++; // 先返回5，$a 再加 1 ++$a; // $a 先加 1，再返回 6 9.逻辑运算符 $a and $b And（逻辑与） TRUE，如果 $a 和 $b 都为 TRUE。 $a or $b Or（逻辑或） TRUE，如果 $a 或 $b 任一为 TRUE。 $a xor $b Xor（逻辑异或） TRUE，如果 $a 或 $b 任一为 TRUE，但不同时是。 ! $a Not（逻辑非） TRUE，如果 $a 不为 TRUE。 $a && $b And（逻辑与） TRUE，如果 $a 和 $b 都为 TRUE。 $a ｜｜ $b Or（逻辑或） TRUE，如果 $a 或 $b 任一为 TRUE。 10.字符串连接符 字符串连接符号 点(.) $a = 1; $b = 222 echo $a . $b; //1222 11.类型运算符 instanceof 用于确定一个 PHP 变量是否属于某一类 $c = new C(); $c instanceof C; Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/04.流程控制.html":{"url":"PHP-基础知识/04.流程控制.html","title":"04.流程控制","keywords":"","body":"04.流程控制 1. if、else if($a == 1) { echo '1'; }else if($a == 2) { echo '2'; }else{ echo 'other'; } #简写 不推荐 if ($a == 1): echo \"1\"; else: echo \"else\"; endif; 2.switch switch 类似于一系列的 if else。每个 case 下都有一个 break。如果没有则继续往下执行。 if($a == 1) { echo '1'; }else if($a == 2) { echo '2'; }else{ echo 'other'; } # swtich switch ($a) { case 1: echo '1'; break; case 2: echo '2'; break; default: echo 'other'; break; } // 其结果只能是其中一个。 switch ($a) { case 1: echo '1'; case 2: echo '2'; default: echo 'other'; break; } // 若 $a=1 , 则值为 12other 3.while、do while while 和 do while都是满足条件后才循环，不满足则跳出。 do while 相比 while 是先执行一次再判断。 $a = 10; while($a>1) { echo $a--;//1098765432 } #do while $b = 1; do{ echo $b; //1 }while($b>1) 4.for foreach for 循环是 PHP 中最复杂的循环结构。它的行为和 C 语言的相似 for (expr1; expr2; expr3){ statement } 第一个表达式（expr1）在循环开始前无条件求值（并执行）一次。 expr2 在每次循环开始前求值。如果值为 TRUE，则继续循环，执行嵌套的循环语句。如果值为 FALSE，则终止循环。 expr3 在每次循环之后被求值（并执行）。 $people = Array( Array('name' => 'Kalle', 'salt' => 856412), Array('name' => 'Pierre', 'salt' => 215863) ); for($i = 0; $i foreach 语法结构提供了遍历数组的简单方式。foreach 仅能够应用于数组和对象 引用修改后，一定要 unset 将 $value 销毁 foreach($array as $key=>$value) { } # 简写 foreach($array as $key=>$value): endforeach; #引用修改 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。 foreach (array(1, 2, 3, 4) as &$value) { $value = $value * 2; } unset($value); 5.break 、continue break 结束当前 for，foreach，while，do-while 或者 switch 结构的执行。break后面可以跟一个数字。表示跳出几重循环 for($i = 0; $i continue 在循环结构用用来跳过本次循环中剩余的代码并在条件求值为真时开始执行下一次循环 continue 接受一个可选的数字参数来决定跳过几重循环到循环结尾。默认值是 1，即跳到当前循环末尾 for($i = 0; $i 6.declare declare 结构用来设定一段代码的执行指令。declare 的语法和其它流程控制结构相似 目前只认识两个指令：ticks encoding Tick（时钟周期）是一个在 declare 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 declare 中的 directive 部分用ticks=N 来指定的 encoding 指令来对每段脚本指定其编码方式。 declare(ticks=1); // A function called on each tick event function tick_handler() { echo \"tick_handler() called\\n\"; } register_tick_function('tick_handler'); $a = 1; if ($a > 0) { $a += 2; print($a); } declare(encoding='ISO-8859-1'); 7.return 在函数中使用return 将结束函数的执行。 return 是语言结构而不是函数，因此其参数没有必要用括号将其括起来。通常都不用括号，实际上也应该不用，这样可以降低 PHP 的负担。 function f(){ return 1; echo '11';//不会执行 } #a.php #b.php // ba 8.include 、require include(path) 会按照给定的参数 进行查找，如果没有找到就到include_path中查找。如果还没有找到，那么就会抛出一个警告。 如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \\ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径。include_path就会被忽略。 require 和include查找文件基本上一致。只是require会抛出一个error错误终止代码的执行。 require 和include是一个语言构造器而不是一个函数 include 'a.php'; echo \"hello\"; # 会输出hello require 'a.php'; echo \"hello\"; # 抛出一个error hello不会输出。 9.include_once 、require_once include_once 、require_once 语句在脚本执行期间包含并运行指定文件.如果该文件中已经被包含过，则不会再次包含 include_once 会抛出warning 。require_once 会抛出error 10.goto goto操作符并不常用。用来跳转程序的一个位置。目标位置只能位于同一个文件和作用域 无法跳出一个函数或类方法，也无法跳入到另一个函数。也无法跳入到任何循环或者 switch 结构中 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/05.函数.html":{"url":"PHP-基础知识/05.函数.html","title":"05.函数","keywords":"","body":"05.函数 函数名命名规则与变量名命名规则一直，以字母或下划线打头，后面跟任意字母、数字、下划线。 要避免递归函数／方法调用超过 100-200 层，因为可能会使堆栈崩溃从而使当前脚本终止 PHP 中的所有函数和类都具有全局作用域。PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。 1.自定义函数 function 函数名(参数 1,参数 2....参数 n){ // 函数体 } 2.函数参数 可以通过参数将函数外部信息传到内部 函数可以有默认值，顺序先非默认值参数，后有默认值参数 函数的参数可以指定类型，指定的类型可以是，类名、接口名、self、array、callback。php7.0 之后支持 bool、float、int、string。 function demo(ClassName $class_name,String $arg2 = 'apple'){ } 引用参数，默认情况下传入函数的参数值是不会改变的，当需要使传入值改变时，可以使用 & 引用。 4.严格类型 默认情况下，如果能做到的话，PHP将会强迫错误类型的值转为函数期望的标量类型。 在严格类型下，则不会。并且会报错，唯一的例外时将 integer 类型传给期望是 float 类型的函数。 declare(strict_types=1); function fn2(float $a){ echo $a; } $c = 1; fn2($c); // 输出 1 function fn(int $a){ echo $a; } $c = '1';//string fn($c);// 报错 5.可变参数的参数列表 PHP 在用户自定义函数中支持可变数量的参数列表。在 PHP 5.6 及以上的版本中，由 ... 语法实现 6.返回值类型 函数的返回值可以通过 return 返回。返回任意类型，返回后立即终止函数的运行，并且将控制权返还给调用函数行。 function fn(){ return \"hello\"; } 在 php7.0 之后，可以限制返回值的类型。 当覆盖一个父类方法时，子类方法的返回值类型声明必须与父类一致。如果父类方法没有定义返回类型，那么子类方法可以定义任意的返回值类型声明。 declare(strict_types=1); function($a):float { return 1.1; } 7.可变函数 php 支持可变函数概念，即在变量后加括号()，则会调用变量值同名的函数。不能用于系统函数如 echo，print，unset()，isset()，empty()，include，require 。 function foo(){ echo 1; } $a = foo; $a(); // 输出 1 8.匿名函数 匿名函数也叫闭包函数。 闭包可以从父作用域中继承变量。 任何此类变量都应该用 use 语言结构传递进去 (function (){ echo '匿名函数'; })(); #传递参数 $a = function ($arg) { echo $arg; } $arg = 'hello'; $a($arg);//hello; # 传递外部作用域变量 $arg = 'arg'; $f = function() use($arg){ echo $arg; } $f(); Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/06.类与对象1.html":{"url":"PHP-基础知识/06.类与对象1.html","title":"06.类与对象1","keywords":"","body":"06.类与对象1 类：类是对象的类型，将现实世界的有统一特征的个体抽象出来的结果。如人类、动物类、商品。 对象：对象是类的实例。有统一特征的抽象结果的实例，单独其中一个个体，如动物类的实例可以是猫，狗。 属性：是对象的一个特征，如猫的毛色，种类。 方法：是对象能够执行的动作。如猫可以走、跑、跳、睡觉。 1.类的定义 类名的定义规则与变量、函数的命名方式相同。以字母或下划线开头，跟任意字母、数字、下划线。最后一堆花括号。 class demo{ // 声明属性 public $var = 'a default value'; // 声明方法 public function displayVar() { echo $this->var; // 表示当前对象 } } $obj = new demo(); // 实例化对象 $obj->displayVar(); // 输出 a default value // ----------------------------------------------------------------------------------------- class A { function foo() { if (isset($this)) { echo '$this is defined ('; echo get_class($this); echo \")\\n\"; } else { echo \"\\$this is not defined.\\n\"; } } } class B { function bar() { A::foo(); } } $a = new A(); $a->foo(); // $this is defined (A) A::foo(); // $this is not defined. $b = new B(); $b->bar(); // $this is defined (B) B::bar(); // $this is not defined. 2.对象的实例化 通过 new 关键字来实例化一个对象，如果该类有命名空间则需要补全命名空间或者在文件开头用 use 引用。 use App; $obj = new className(); // 也可以这样做 $a = 'className'; $obj = new $a(); 对象赋值 $instance = new SimpleClass(); $assigned = $instance; $reference = &$instance; $instance->var = '$assigned will have this value'; $instance = null; // $instance and $reference become null var_dump($instance); // null var_dump($reference); // null var_dump($assigned); // object(SimpleClass)#1 (1) 3.类的继承 一个类在声明时使用 extends 关键字来继承另一个类的属性和方法。一个类只能继承一个类，不支持多继承。 displayVar(); // 输出 Extending class // a default value ?> 4.::class 自 PHP 5.5 起，关键词 class 也可用于类名的解析。使用 ClassName::class 可以获得类名，如果该类声明了命名空间，则会包括命名空间完整显示。 5.类的属性 类的变量叫类的属性。类的声明由 public 、protected 、 private 开头，然后跟上普通变量名。 在类的成员方法中，可以通过 ->(对象运算符) 来获取，如果是静态方法，则通过 self:: 来获取。 class demo{ public $a=1; public static $b=2; public function foo(){ echo $this->$a; // 1 echo self::$b; // 2 } } $obj = new demo(); $obj->foo(); 6.类常量 在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号 类常量是一个定值。类常量使用 const 定义。访问的时候使用 self:: 访问类常量 接口（interface）中也可以定义常量。更多示例见文档中的接口部分。 class demo{ const PI=3.14; } echo demo::PI; // 3.14 7.类的自动加载 类的自动加载可以不用手动 include 各个类文件。 自动加载不可用于 PHP CLI 模式 spl_autoload_register(function ($class_name) { require_once $class_name . '.php'; }); $obj = new demo1(); 8.构造函数和析构函数 构造函数 __construct()：当实例化一个对象时，立即执行的函数，非常适合用于初始化对象。 析构函数 __destruct()：析构函数在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用parent::__construct() 试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。 name = \"MyDestructableClass\"; } function __destruct() { print \"Destroying \" . $this->name . \"\\n\"; } } $obj = new MyDestructableClass(); // 输出 In constructor // Destroying MyDestructableClass class P{ public function __construct(){ echo \"construct\"; } public function __destruct(){ echo \"destruct\"; } } $p = new P();// construct; unset($p);//destruct; ?> 9.访问控制（可见性） 对属性和方法的访问控制，可以通过，public（公有）,protected（受保护的），private（私有的）三种方式来实现。 public （默认）: 任何成员都可以访问。 protected :只能其自身或子类访问。 private : 只能自身访问。 class A{ public $name = 'a'; protected $age = 10; private $money = 100; } class B extends A{ public function test(){ echo $this->age;//a } public function testPrivate(){ echo $this->money; } } $b = new B(); echo $b->name;//a echo $b->test();//10 # 不可访问 echo $b->age;//error; #子类不能访问 echo $b->testPrivate();//error 10.范围解析操作符（::） 范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量。还可以用于覆盖类中的属性和方法。 self，parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的 当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。使用self调用父类，使用$this 调用本类。 class A{ public $name = 'a'; protected $age = 10; private $money = 100; } class B extends A{ public static $s = 's'; const PI = 111; public function test(){ echo parent::age;// 10 } public static function testStatic(){ echo self::$s; } public function testConst(){ echo self::PI; } public function testPrivate(){ echo $this->money; } } # self 和 $this class ParentClass { function test() { self::who(); // will output 'parent' $this->who(); // will output 'child' } function who() { echo 'parent'; } } class ChildClass extends ParentClass { function who() { echo 'child'; } } $obj = new ChildClass(); $obj->test();// 11.static 静态关键字 声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以） 静态属性不可以由对象通过 -> 操作符来访问。静态属性只能被初始化为文字或常量。静态属性不随着对象的销毁而销毁。 class P{ $a = \"world\"; public static function test(){ echo \"hello\".self::$a; } } p::test(); Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/07.类与对象2.html":{"url":"PHP-基础知识/07.类与对象2.html","title":"07.类与对象2","keywords":"","body":"07.类与对象2 1.抽象类 PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。当一个类中有一个方法是抽象方法则，这个类就是抽象类 继承一个抽象类后，子类必须实现抽象类中所有抽象方法。 某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。 此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。 abstract class AbstractClass { abstract public function test(); } class Son extends AbstractClass{ public function test(){ echo \"test\"; } } 2.对象接口 使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。 使用接口（interface）定义的类，和定义一个标准类一样，不过所有的方法都必须是空的。（不可定义属性） 接口的所有方法都必须是公有的。 使用 implements 关键字来实现一个接口。可以一次性实现多个接口。实现多个接口时，方法不能重名。 接口可以继承，使用 extends 关键字。 类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。 foo1(); $obj->foo2(); $obj->foo3(); 3.trait 自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。 trait 可以让单继承的语言准备进行代码复用，避免传统多继承带来的问题。 sayHello(); echo 'World'; } } $obj = new world(); $obj->sayHelloWorld(); // Hello World 从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。 即：当前类 > trait > 被继承的类 sayHello(); ?> 多个 trait sayHello(); $o->sayWorld(); $o->sayExclamationMark(); ?> 如果多个trait中。都有同名的方法，则会产生冲突，冲突会产生一个致命的错误。 可以使用 insteadof 来指明当产生冲突时，使用哪一个。 as 操作符可以 为某个方法引入别名 smallTalk(); // b $obj->bigTalk(); // A $obj->talk(); // B 使用 as 语法还可以用来调整方法的访问控制。 smallTalk(); // 报错 $obj->bigTalk(); $obj->talk(); 使用 trait 来组成 trait sayHello(); $obj->sayWorld(); trait 的抽象方法、静态成员、属性 hello; } } class MyHelloWorld{ use HelloWorld; } $obj = new MyHelloWorld(); $obj->sayHello(); $obj->sayWorld(); 4.匿名类 php 7 之后支持匿名类，匿名类很有用，可以创建一次性的简单对象。 $a = new class{ public function say(){ echo 'Hello'; } }; $a->say(); // Hello 匿名类被嵌套进普通 Class 后，不能访问这个外部类（Outer class）的 private（私有）、protected（受保护）方法或者属性。 为了访问外部类（Outer class）protected 属性或方法，匿名类可以 extend（扩展）此外部类。 为了使用外部类（Outer class）的 private 属性，必须通过构造器传进来： class Outer { private $prop = 1; protected $prop2 = 2; protected function func1() { return 3; } public function func2() { return new class($this->prop) extends Outer { private $prop3; public function __construct($prop) { $this->prop3 = $prop; } public function func3() { return $this->prop2 + $this->prop3 + $this->func1(); // 2+1+3 } }; } } echo (new Outer)->func2()->func3(); // 6 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/08.类与对象3.html":{"url":"PHP-基础知识/08.类与对象3.html","title":"08.类与对象3","keywords":"","body":"08.类与对象3 1.重载与重写 重写是指覆盖原方法，一般用于子类继承父类重写父类方法。 PHP 提供的“重载”是动态的“创建”类的属性和方法。通过使用魔术方法来实现。 当调用当前环境下未定义的属性和方法是，则会调用魔术方法。 在给不可访问属性赋值时，__set() 会被调用。 读取不可访问属性的值时，__get() 会被调用。 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问属性调用 unset() 时，__unset() 会被调用。 在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 $name; } public function __set($name,$value){ $this->$name=$value; } public function __isset($name){ echo \"isset $name\".PHP_EOL; } public function __unset($name){ echo \"unset $name\".PHP_EOL; } public function __call($name,$args){ $args = implode(',', $args); echo \"call $name ,args is {$args}\".PHP_EOL; } public static function __callStatic($name,$args){ $args = implode(',', $args); echo \"call static $name ,args is {$args}\".PHP_EOL; } } $obj = new demo(); $obj->a = 'b'; echo $obj->a.PHP_EOL; // b isset($obj->a); // isset a unset($obj->a); // unset a $obj->say('Hello','World'); // call say ,args is Hello,World demo::staticSay('World','World'); // call static staticSay ,args is World,World 2.多态 统一操作，作用于不同对象，得到不同的结果。如数据库操作，$db->query(); 可以是 mysql 的操作，也可以是redis 的 query(); } run(new mysql()); // query mysql run(new redis()); // query redis 3.遍历对象 遍历对象可以使用foreach遍历可见属性。或者实现iterator接口 $v) { echo $key.\"=>\".$v.PHP_EOL; } // var1=>value 1 // var2=>value 2 // var3=>value 3 4.魔术方法 __construct 初始化调用 __desturct 对象销毁时调用 __call 访问一个不存在的方法的时候调用 __callStatic 访问一个不存在的静态方法调用 __get() 访问一个不存在的属性调用 __set() 修改一个不存在的属性调用 __isset() 使用 isset 判断一个高属性的时候调用 __toString() 当一个对象以一个字符串返回时候触发调用 __invoke() 当把一个对象当函数去调用的时候触发 __sleep() 当使用 serialize() 时调用 __wakeup() 当使用 unserialize() 时调用 server]; } public function __wakeup(){ return $this->server; } } $c = new MyClass(); $c(5); // int(5) var_dump($d = serialize($c)); // string(44) \"O:7:\"MyClass\":1:{s:6:\"server\";s:6:\"server\";}\" var_dump(unserialize($d)); //object(MyClass)#2 (1) { // [\"server\"]=> // string(6) \"server\" // } 5.Final 关键字 被 final 修饰的类不能被继承。 如果一个类中某个方法被 final ，这个类不能被重写。 final 不能修饰属性。 6.对象的复制和比较 对象的复制通过 clone 关键字来完成。这将会调用 clone() 方法。对象中的 clone() 方法不能被直接调用 当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。 当复制完成时，如果定义了 clone() 方法，则新创建的对象（复制生成的对象）中的 clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 a = 'b'; } public function say(){ echo $this->a.PHP_EOL; } } $a = new MyClass(); $b = clone $a; $a->say(); // a $b->say(); // b 当使用比较运算符（==）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。 而如果使用全等运算符（===），这两个对象变量一定要指向某个类的同一个实例（即同一个对象） 7.类型约束 函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组 query(); } } $obj = new demo(); $obj->run(new mysql()); // query mysql $obj->run(new redis()); // query redis 8.静态绑定 self 调用的方法是所定义的类所定义的方法。 static 调用的方法是调用类的方法。 9.对象和引用 PHP 的引用是别名，就是两个不同的变量名字指向相同的内容。在 PHP 5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。 当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。 $b->foo = 2; echo $a->foo.\"\\n\"; Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/09.命名空间.html":{"url":"PHP-基础知识/09.命名空间.html","title":"09.命名空间","keywords":"","body":"09.命名空间 命名空间简单来说就是为了解决命名重复而造成的系统冲突。其思想来源于文件路径，\"同一路径下不能存在相同名称的文件\"。 如 www/a、www/b 可以同时存在，www/a/c、www/b/c 也可以同时存在。 1.定义命名空间 命名空间由关键字 namespace 定义。 其必须在程序脚本的第一条语句，否则会报致命错误。除 declare 之外。 子命名空间,中间由 \\ 隔开 2.同一文件定义多个命名空间 3.命名空间基础：命名空间与路径类似，分为非限定名称、限定名称、完全限定名称。 非限定名称，不加前缀的名称，如 $a = new foo(), foo::staticmethod()。如果当前命名空间是 currentnamespace，则 foo 就会被解析成 currentnamespace\\foo。 限定名称，包含前缀的名称，如 $a = new subnamespace\\foo(),或 subnamespace\\foo::staticmethod()。如果当前命名空间为 currentnamespace，则会被解析为 currentnamespace\\subnamespace\\foo。 完全限定名称，如 $a = new currentnamespace\\subnamespace\\foo(), currentnamespace\\subnamespace\\foo::staticmethod()。 // file1 // file2 // file3 4.namespace 与 NAMESPACE 常量 NAMESPACE 表示当前的命名空间，如果在全局中，则返回一个空字符串。 关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。 5.别名与导入 使用 use 关键字来导入命名空间 使用 as 关键字来给命名空间取别名，可以给类、接口、命名空间使用别名。 6.全局命名空间 如果没有定义任何命名空间，则为全局空间，调用时在前面加斜杠 (\\) 7.名称规则解析 类名称总是会解析到当前命名空间中，如果不存在则需要使用完全限定命名空间。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"PHP-基础知识/10.PHP-FPM 与 Nginx.html":{"url":"PHP-基础知识/10.PHP-FPM 与 Nginx.html","title":"10.PHP-FPM 与 Nginx","keywords":"","body":"10.PHP-FPM 与 Nginx 1.基础 静态数据 在整个网站架构中，web server 只是一个内容分发者。如客户端请求的是 index.html 时，web server 会在文件系统中找到这个 index.html 文件，发送给浏览器，这里分发的事静态数据。 动态数据 如果请求的是 index.php 文件，那么 web server 会将客户端的请求数据，通过 CGI 协议转发给 PHP 解析器来处理。 当 web server 收到 index.php 请求后，会启动相应的 CGI 程序，CGI 程序会找到 PHP 的配置文件 php.ini 进行程序的初始化，然后处理请求，再以规定的 CGI 的规定转换为相应的格式返回给 web server，最后返回给客户端。这就是一个完整的访问流程。 2.几个概念： Web Application：指 Apache 、Nginx Web Server：指 PHP、Java 等。 CGI：通用网关接口（Common Gateway Interface），是 Web Server 和 Web Application 之间的一种数据交换协议。 CGI 就相当于两个不同国家的人用来交流的翻译器。Web Server 将数据（url，查询字符串，POST 数据，HTTP header 等）通过标准的输入传递给 Web Application ， Web Application 根据配置文件初始化后(如 PHP 解析器会先根据 php.ini 文件进行初始化)，再处理数据，通过标准的输出返回给 Web Server。 但是 CGI 有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的 fork-and-execute 模式，这样一在大规模并发下，就死翘翘了。 FastCGI：同 CGI，是一种通信协议，在 CGI 的效率上做了优化。 做了哪些优化呢，“PHP 解析器会先根据 php.ini 文件进行初始化” 这里。每次执行程序都会执行一次这个操作，随着 web 的兴起，高并发是常态，这样低效且浪费资源的方式，导致处理每个请求都耗费很长时间。 FastCGI 会先启动一个 master，解析配置文件，初始化执行环境，然后在启动多个 worker。当有新请求过来时，通过 master 会传递给 worker 然后立即执行下一给请求，这样就避免了重复劳动，提高了效率。 当 worker 不够用可以根据配置提前启动几个 worker 等着。当 worker 多余时，也会停掉一些，这样就提高了性能，节约了资源。 FastCGI 是一个常驻性版本的 CGI，它可以一直执行，不用每次都花费时间去 fork。 FastCGI 接口方式采用 C/S 的架构，可以将 Web Server 和 Web Application 分开，同时在服务器上启动一个或多个守护进程。当有请求过来时，直接发送给 FastCGI 进程处理，将结果返回给浏览器。这种方式可以让 Web Server 专心处理静态数据或者将动态数据传给 Web Application ,很大程度上提高了性能。 PHP-CGI：是 PHP（Web Application）对 Web Server 提供的 CGI 的接口程序。 官方出品的 CGI 程序。但是性能太差。 在修改了 php.ini 文件后，必须重启 PHP-CGI 才能让新 php.ini 生效。无法平滑重启 直接杀死 PHP-CGI 后程序将无法执行。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 的接口程序。还提供了相对智能的任务管理。 PHP-FPM 是 FastCGI 的具体实现，负责管理一个进程池，处理 Web Server 的请求。 是一个 PHP 进程管理器，包含 master 和 worker 两种进程。master 进程只有一个，负责监听端口，接收来自服务器的请求，而 worker 根据配置可以有多个，每个进程内部嵌入了一个 php 解释器，是 PHP 代码真正执行的地方。 具体步骤如下： FPM 的 master 接受请求 master 根据配置指定给 worker 进行请求处理，如没有可用 worker 则返回错误，nginx 报 502。 worker 请求超时，返回错误，nginx 报 504。 请求处理结束，返回结果。 当修改了 php.ini 之后，PHP-CGI 程序是无法重启的。所以 PHP-FPM 的做法是当旧的进程处理完旧请求后，杀死。通过启动新的 worker 进程来启用新的配置，这样实现平滑重启。 3.nginx Nginx 不仅仅是一个 Web 服务器，也是一个功能强大的 Proxy 服务器。提供了很多协议，如 HTTP，当然也有与 FPM 相关的 FastCGI 协议。Nginx 提供了 FastCGI 模块来将 HTTP 请求映射为对应的 FastCGI 请求。 Nginx 的 FastCGI 模块提供了 fastcgi_param 指令，主要处理参数的映射关系。这些都是基本不变的，会单独放在一个文件中。 $ cat /usr/local/nginx/conf/fastcgi.conf fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param REQUEST_URI $request_uri; fastcgi_param DOCUMENT_URI $document_uri; fastcgi_param DOCUMENT_ROOT $document_root; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param REQUEST_SCHEME $scheme; fastcgi_param HTTPS $https if_not_empty; fastcgi_param GATEWAY_INTERFACE CGI/1.1; fastcgi_param SERVER_SOFTWARE nginx/$nginx_version; fastcgi_param REMOTE_ADDR $remote_addr; fastcgi_param REMOTE_PORT $remote_port; fastcgi_param SERVER_ADDR $server_addr; fastcgi_param SERVER_PORT $server_port; fastcgi_param SERVER_NAME $server_name; 在 Nginx 的服务器配置中，最重要的 fastcgi_pass 指令，这个指令用于监听 FPM 进程地址，Nginx 会把所有的 php 请求 翻译成 FastCGI 请求再发送给这个地址。下面一个服务器配置实例。 server { listen 80; server_name test.me; root /usr/local/web/myproject/public; index index.php index.html index.htm; access_log /usr/local/nginx/logs/test-access.log; error_log /usr/local/nginx/logs/test-error.log; location / { try_files $uri $uri/ /index.php?$query_string; } location ~\\.php$ { include fastcgi_params; fastcgi_param SCRIPT_FILENAME /usr/local/web/myproject/public/$fastcgi_script_name; fastcgi_pass unix:/usr/local/php/var/run/php-fpm.sock; fastcgi_index index.php; } } 在这个配置文件中，我们新建了一个虚拟主机，监听端口 80，项目根目录为 /usr/local/web/myproject/public。然后通过 location 指令，将所有以 .php 结尾的请求都交给 FastCGI 模块处理。从而把所有的PHP请求都交给了FPM处理，从而完成Nginx到FPM的闭环。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/01.基础数据结构.html":{"url":"Redis/01.基础数据结构.html","title":"01.基础数据结构","keywords":"","body":"01.基础数据结构 Redis 有五种数据结构，分别是 String（字符串）、List（列表〉、Hash （字典〉 、 Set（集合）和 Zset（有序集合〉。 1.String 字符串 Redis 的字符串是动态字符串，是可以修改的字符串，采用预分配冗余空间的形式来减少内存的频繁分配。 当字符串小于 1M 时，按原来的的空间加倍来扩容。如当前空间 16kb，扩容后是 32kb。 当字符串大于 1M 时，只会比当前空间多加 1M 来扩容。如当前空间 2M，扩容后是 3M。 Redis 的 String 类型最大长度是 512MB。 String 的用途 缓存用户信息，通过对 json 序列化，将用户所有信息存储到 String。同样以 json 反序列化来取出用户数据。 # 设置键值对， set [key] [value] > set name codehole OK # 获取某个键， get [key] > get name \"codehole\" # 查询某个键是否存在， exists [key] > exists name (integer) 1 # 删除某个键 ，del [key] > del name (integer) 1 > get name # 再次查询则已经被删除 (nil) 批量设置键值对，可以节省网络耗时开销 # 批量赋值， mset [key1] [value1] [key2] [value2] .... > mset name1 boy name2 girl name3 unknown OK # 批量查询，mget [key1] [key2] ... > mget name1 name2 name3 1) \"boy\" 2) \"girl\" 3) \"unknown\" 过期和 set 的扩展命令 # 给某个键添加过期时间， expire [key] [secend] > set name codehole > get name ” codehole \" > expire name 5 ... # wait for 5s > get name # 已经被删除了 (nil) # 当对一个有 ttl 的 key 进行重新赋值时，会删除原来的 ttl # 设置键值对并且设置过期时间， setex [key] [expire] [value] > setex name 5 codehole # 5s 后过期，等价于 set+expire > get name \"codehole\" ... # wait for 5s > get name (nil) # 设置键值对，若存在则不创建，否则创建。 setnx [key] [value] > setnx name codehole # 如果 name 不存在就执行 set 创建 (integer) 1 > get name \"codehole\" > setnx name holycoder (integer) 0 # 因为 name 已经存在，所以 set 创建不成功 > get name \"codehole\" # 没有改变 计数 > set age 30 OK # 通过 incr [key], incrby [key] [increment] 来做加法 # 通过 decr [key], decrby [key] [decrement] 来做减法 > incr age (integer) 31 > incrby age 5 (integer) 36 > incrby age -5 (integer) 31 > decrby age 5 (integer) 26 # 如果 value 是一个整数，那么他的范围是在 signed long 的最大和最小值之间。超过范围则 Redis 报错。 > set codehole 9223372036854775807 # Long.Max OK > incr codehole (error) ERR increment or decrement would overflow 2.List 列表 Redis 的列表是个链表，对于插入和删除操作的时间复杂度是 O(1)。但是索引定位 index 会很慢，时间复杂度为 O(n)。 当列表弹出最后一个元素后，则该数据结构被自动删除，内存释放。 #从 左/右 边压入，lpush/rpush [key] [value1] [value2] [value3] #从 左/右 边弹出，lpop/rphp [key] 队列：右进左出，先进先出 常用于消息队列和异步逻辑处理，确保元素的访问顺序性> rpush books python java golang (integer) 3 > llen books (integer) 3 > lpop books \"python\" > lpop books \"java\" > lpop books \"golang\" > lpop books (nil) 栈：右进右出 > rpush books python java golang (integer) 3 > rpop books \"golang\" > rpop books \"java\" > rpop books \"python\" > rpop books (nil) 慢操作 > rpush books python java golang (integer) 3 # 查寻元素，从 0 开始，index 可以为负数，-1 表示最后一个。lindex [key] [index] > lindex books 1 # O(n) 慎用 \"java\" > lrange books 0 -1 # 获取所有元素，O(n) 慎用 1) \"python\" 2) \"java\" 3) \"golang\" # 截取其中一部分，ltirm [key] [start] [stop] > ltrim books 1 -1 # O(n) 慎用 OK > lrange books 0 -1 1) \"java\" 2) \"golang\" > ltrim books 1 0 # 这其实是清空了整个列表，因为区间范围长度为负 OK # 查看长度， llen [key] > llen books (integer) 0 3.Hash 哈希 Hash 在移除最后一个元素后，该数据结构自动被删除，内存被回收。 常用于存储用户信息，它可以单独设置或取出用户数据，与 String 一次性取出用户所有数据相比，节省了网络流量。但是 Hash 结构的存储消耗要高于单个 String。所以要根据实际情况进行权衡。 # 向键中插入单个列，hset [key] [field] [value] > hset books java \"think in java\" # 命令行的字符串如果包含空格，要用引号括起来 (integer) 1 > hset books golang \"concurrency in go\" (integer) 1 > hset books python \"python cookbook\" (integer) 1 # 获取该键所有列，hgetall [key] > hgetall books # entries()，key 和 value 间隔出现 1) \"java\" 2) \"think in java\" 3) \"golang\" 4) \"concurrency in go\" 5) \"python\" 6) \"python cookbook\" # 查看该键长度，hlen [key] > hlen books (integer) 3 # 查看该键中某列的值，hget [key] [field] > hget books java \"think in java\" > hset books golang \"learning go programming\" # 因为是更新操作，所以返回 0，但是更新成功 (integer) 0 > hget books golang \"learning go programming\" # 批量设置， hmset [key] [field1] [value1] [field2] [value2] ... > hmset books java \"effective java\" python \"learning python\" golang \"modern golang programming\" # 批量 set OK 对单个 key 进行操作，与 String 的 incrby 用法一样。 # 老钱又老了一岁 > hincrby user-laoqian age 1 (integer) 30 4.Set 集合 Redis 中的 set 是一个无需集合，其内部是「唯一」且「无序」的。 当集合中最后一个元素被移除之后， 数据结构被自动删除， 内存被回收。 可以用作存储活动中奖用户的 id。因为有去重功能，可以保证一个用户不会中奖两次。 # 添加一个或多个元素到集合，sadd [key] [value1] [value2]... > sadd books python (integer) 1 > sadd books python # 重复，则不添加 (integer) 0 > sadd books java golang (integer) 2 # 查看一个集合，smembers [key] > smembers books # 注意顺序，和插入的并不一致，因为 set 是无序的 1) \"java\" 2) \"python\" 3) \"golang\" # 判断一个元素是否是集合的元素，sismember [key] [value] > sismember books java # 查询某个 value 是否存在，相当于 contains(o) (integer) 1 > sismember books rust (integer) 0 # 查询一个集合有多少个元素， scard [key] > scard books # 获取长度相当于 count() (integer) 3 # 弹出一个集合元素， spop [key] > spop books # 弹出一个 \"java\" 5.Zset 有序集合 同样是一个集合，但集合中每个元素多了一个 score，代表这个元素在集合中的权重。 Zset 可以用来记录粉丝/点赞列表，value 为 用户 id，score 为关注/点赞时间。 Zset 也可以存储学生成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。 * # 向有序集合中添加一个元素 zadd [key] [score] [value] > zadd books 9.0 \"think in java\" (integer) 1 > zadd books 8.9 \"java concurrency\" (integer) 1 > zadd books 8.6 \"java cookbook\" (integer) 1 # 顺序查询，zrange [key] [start] [stop] > zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围 1) \"java cookbook\" 2) \"java concurrency\" 3) \"think in java\" # 逆序查询，z revrange [key] [start] [stop] > zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围 5) \"think in java\" 6) \"java concurrency\" 7) \"java cookbook\" # 查看集合中元素个数，zcard [key] > zcard books # 相当于 count() (integer) 3 > zscore books \"java concurrency\" # 获取指定 value 的 score \"8.9000000000000004\" # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题 # 查询某个元素在集合中的排名，zrank [key] [value] > zrank books \"java concurrency\" # 排名 (integer) 1 # 查询某个 score 段的元素，zrangebyscore [key] [range_start] [range_end] > zrangebyscore books 0 8.91 # 根据分值区间遍历 zset 1) \"java cookbook\" 2) \"java concurrency\" > zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。 1) \"java cookbook\" 2) \"8.5999999999999996\" 3) \"java concurrency\" 4) \"8.9000000000000004\" # 删除某个元素，zrem [key] [value] > zrem books \"java concurrency\" # 删除 value (integer) 1 > zrange books 0 -1 1) \"java cookbook\" 2) \"think in java\" 6.容器型数据结构的通用规则 list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则： create if not exists 如果容器不存在，则创建一个，再进行操作。如 hset 时没有 hash 容器，先创建一个容器，再进行插入。 drop if no elements 如果一个容器没有任何元素了，则删除容器。如 lpop 弹出最后一个元素，则删除该队列。 7.过期时间 Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。 如果一个字符串设置了时间，然后用 set 方法修改了它，那么它的过期时间则会消失。 127.0.0.1:6379> set codehole yoyo OK # 所有容器都支持这个语法 ， expire [key] [secend] 127.0.0.1:6379> expire codehole 600 (integer) 1 127.0.0.1:6379> ttl codehole (integer) 597 127.0.0.1:6379> set codehole yoyo OK 127.0.0.1:6379> ttl codehole (integer) -1 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/02.分布式锁.html":{"url":"Redis/02.分布式锁.html","title":"02.分布式锁","keywords":"","body":"02.分布式锁 原子性：是运行过程中的最小单位。 原子操作：指在不会被线程调度机制打断的操作。这种操作一旦开始，会一直运行到结束，不会被打断。 分布式锁：很常见的例子是，通过某个接口查询数据库，由于访问量大，一般都会加一层缓存，并且加上过期时间。但是这里有个问题是，当缓存过期的瞬间，会有大量的请求穿透去数据库查询，导致宕机。而分布式锁就可以解决这个问题。 分布式锁至少需要满足几个条件： 互斥，在任何时刻，同一个锁只能由一个客户端用户锁定。 不会死锁，就算持有锁的客户端在持有期间崩溃了，也不影响其他客户端用户加锁。 谁加锁谁解锁。就是解锁要验证客户端身份，不能被其他客户端解锁。 错误的方式 1.通常会以这一的方式来加锁 >setnx lock-key true OK ... do something ... >del lock-key OK 这里会有个问题，如果在加锁后，执行 del 之前服务器挂了，那么锁就不会被删除，会导致死锁。 好，那么加一个过期时间怎么样。看下面这个例子 2.加过期时间 在上个例子中，加上过期时间。 >setnx lock-key true OK # 加上过期时间 expire lock-key 5 ... do something ... >del lock-key OK 加上过期时间后应该就不会死锁了吧。但是，如果在 setnx 和 expire 之间，服务器挂了呢，同样也会造成死锁这个问题。 发现问题了吧，原因是 setnx 和 expire 这两个操作是两个命令而不是一个原子操作。不过好在 Redis 官方给了个解决方案，使用 set 命令。 3.使用 set 命令 从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改： set 命令：SET key value [EX|PX] [NX|XX] EX|PX ：过期时间，单位秒/毫秒。 NX：只有键不存在，才对键进行操作。 SET key value NX 效果等同于 SETNX key value 。 XX：只有键存在，才对键进行操作。 那么我们使用 set 来修改上面的列子。 >set lock-key true EX 5 NX OK ... do something ... >del lock-key OK 4.超时问题 在上面例子中，我们解决了加锁问题，但是还有一些问题没有解决。如果客户端 A 持有锁过期了，但是它的临界区的逻辑没有执行完，客户端 B 提前持有了锁，导致代码代码无法严格串行执行下去。 这里产生了两个问题： 验证锁的所有者 删除锁 很遗憾，Redis 中没有「验证锁」同时「删除锁」的原子性操作。不过可以使用 lua 脚本来实现。 if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else return 0 end PHP 实现 set($key, $requireId, self::MILLISECONDS_EXPIRE_TIME, $expireTime, self::IF_NOT_EXIST); return (String)$result === self::LOCK_SUCCESS; } /** * @param \\Predis\\Client $redis redis客户端 * @param String $key 锁 * @param String $requireId 请求 id * @return bool */ public static function releaseLock(\\Predis\\Client $redis, String $key, String $requireId) { // lua 脚本 $lua = eval($lua, 1, $key, $requireId); return self::RELEASE_SUCCESS === $result; } } 可重入性 可重入性：是指线程在持有锁的情况下再次请求加锁， 如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。 暂时没体会到有什么作用，等以后了解用法后再更新。 应用 在 VRM 中，修改仓库设置，用到了 redis 分布式锁。防止多人同时修改仓库设置。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/03.延时队列.html":{"url":"Redis/03.延时队列.html","title":"03.延时队列","keywords":"","body":"03.延时队列 一般常用的消息队列有 RabbitMQ, KAFKA 这样强大的中间件，可以再应用之间进行异步地消息传递功能。它们功能强大并专业，特性诸多，但是使用起来也比较繁琐。 有了 redis，可以从中解脱出来，不过如果对消息的可靠性有较高的要求，那么 redis 就不适合了，还是得用 RabbitMQ, KAFKA 专业的中间件来。 异步消息队列 使用 redis 的 List 数据结构来作为消息队列，通过 lpush,rpop 或者 rpush,lpop 进行插入和消费。 这里会存在一个问题，如果队列空了会怎么办。 我们可以 sleep 一会，降低 CPU 占用率和 QPS。但是这也会导致消息队列产生延迟问题。 所以，可以通过 blpop/brpop 替代前面的 lpop/rpop。通过阻塞读的方式来降低 CPU 和 QPS，并且延迟几乎为零。（b 代表 blocking 阻塞读：在队列没有数据的时候，会立即进入休眠状态，一旦数据来了便立即醒来。） 但是，上面的方案还是有问题，因为如果线程一旦阻塞在那里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器便会主动断开，减少闲置资源占用。这个时候 blpop/brpop 就会抛出异常。 所以，消费的时候一定要注意，捕获异常并重试 锁冲突问题 如果客户端加锁没加成功该怎么办呢？ 直接抛出异常，通知用户重试。 这种本质上是放弃当前请求，让用户决定是否重新尝试。 sleep 一会再重试。 sleep 会阻塞当前线程，并且导致队列后续消息产生延迟。如果因为个别死锁 key 导致加锁不成功，线程便会彻底堵死，后续任务永远无法处理。 将请求转入延时队列，过会再重试。 这种方式比较适合异步消息处理，将当前冲突的请求移到另一个队列延后处理以避开冲突。 延迟队列实现 一般通过 Redis 的 zset（有序集合） 数据结构来实现。将消息序列化为一个字符串作为 zset 的 value，到期时间作为 score，然后采用多线程轮询的方式来进行处理。多线程为了保障可用性，万一挂了一个线程，其他线程也能正常处理。但是有多线程，还要解决并发争抢任务，防止一个任务被执行多次。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/04.位图.html":{"url":"Redis/04.位图.html","title":"04.位图","keywords":"","body":"04.位图 Redis 可以做位运算。如同正常的位运算一样。 用处： 用户签到：月签，年签，利用 Redis 的位图可以轻松统计出用户每月/年的签到次数。想想如果有上亿用户，签到需要的空间是非常惊人的。 用户在线人数统计：用户 id 主键为比特位，在线为 1，不在线为 0，通过位图轻松记录有多少人在线，或者确定谁在线。1亿用户只需要 10M 的大小就能做到（100000000/1024(mb)/1024(kb)/8（bit））。 基本用法 如 'h' 这个字符，通过 Python 的 bin(ord('h')) 可以将 h 转换为 ASCII 码「104」，再转换为二进制即 「01101000」。 比特位 0 1 2 3 4 5 6 7 比特值 0 1 1 0 1 0 0 0 通过 set 方法创建一个 h，然后通过 getbit 来获取转化成二进制的字符在指定比特位的值。 获取指定位置的比特位的值 getbit [key] [offset] 127.0.0.1:6379> set demo h # 设置一个键为 h，其二进制是 01101000 OK 127.0.0.1:6379> getbit demo 0 # 比特位第一位 0 (integer) 0 127.0.0.1:6379> getbit demo 1 # 比特位第一位 1 (integer) 1 127.0.0.1:6379> getbit demo 2 (integer) 1 127.0.0.1:6379> getbit demo 3 (integer) 0 127.0.0.1:6379> getbit demo 4 (integer) 1 127.0.0.1:6379> getbit demo 5 (integer) 0 127.0.0.1:6379> getbit demo 6 (integer) 0 127.0.0.1:6379> getbit demo 7 (integer) 0 第二个例子，我们通过设置比特位「01101000」创建一个 h 字符。 设置指定位置的比特位的值 setbit [key] [offset] [value] 127.0.0.1:6379> setbit demo2 0 0 (integer) 0 127.0.0.1:6379> setbit demo2 1 1 (integer) 0 127.0.0.1:6379> setbit demo2 2 1 (integer) 0 127.0.0.1:6379> setbit demo2 3 0 (integer) 0 127.0.0.1:6379> setbit demo2 4 1 (integer) 0 127.0.0.1:6379> setbit demo2 5 0 (integer) 0 127.0.0.1:6379> setbit demo2 6 0 (integer) 0 127.0.0.1:6379> setbit demo2 7 0 (integer) 0 127.0.0.1:6379> get demo2 \"h\" 当对应的字节不可打印时，则 Redis 会返回一个十六进制的值 127.0.0.1:6379> setbit x 0 1 (integer) 0 127.0.0.1:6379> setbit x 1 1 (integer) 0 127.0.0.1:6379> get x \"\\xc0\" 统计与查找 统计一个键从第 start 个「字符」到第 end 个「字符」的「比特位」有多少个「1」，bitcount [key] [start] [end] 注意这里的 start 是字符，如 hello 的第一个字符是 h。 127.0.0.1:6379> set w hello OK 127.0.0.1:6379> bitcount w # hello 转换成二进制后有 21 个 1 (integer) 21 127.0.0.1:6379> bitcount w 0 0 # 统计第一个字符 h 中有多少个 1。 (integer) 3 127.0.0.1:6379> bitcount w 0 4 # 统计从第一个字符开始到第五个字符有多少个 1 (integer) 21 127.0.0.1:6379> bitcount w 1 4 # 统计从第二个字符开始到第五个有多少个 1 (integer) 18 返回从第 start 个字符到第 end 个字符之间，第一个比特值为 1 的比特位的位置，bitpos [key] [start] [end] 127.0.0.1:6379> set w hello OK 127.0.0.1:6379> bitpos w 1 1 1 # 从第二个字节开始，第一次出现的 1 的比特位是 9。 (integer) 9 127.0.0.1:6379> bitpos w 1 2 2 # 从第三个字节开始，第一次出现的 1 的比特位是 17。 (integer) 17 运算 对一个或多个 key 进行位运算。 bitop and destkey key [key...] 对一个或者多个 key 求逻辑并，并将结果保存到 destkey bitop or destkey key [key...]对一个或者多个 key 求逻辑或，并将结果保存到 destkey bitop xor destkey key [key...]对一个或者多个 key 求逻辑异或，并将结果保存到 destkey bitop not destkey key 对给定 key 求逻辑非，并将结果保存到 destkey。注意这里只能是一个 key 示例： 127.0.0.1:6379> set a a OK 127.0.0.1:6379> set c c OK 127.0.0.1:6379> bitop and result a c (integer) 1 127.0.0.1:6379> get result \"a\" 127.0.0.1:6379> bitop or result2 a c (integer) 1 127.0.0.1:6379> get result2 \"c\" 127.0.0.1:6379> bitop xor result3 a c (integer) 1 127.0.0.1:6379> get result3 \"\\x02\" 127.0.0.1:6379> bitop not result4 a c # 注意这里取否只能是一个 key，两个会报错 (error) ERR BITOP NOT must be called with a single source key. 127.0.0.1:6379> bitop not result4 a (integer) 1 127.0.0.1:6379> get result4 \"\\x9e\" 魔术指令 bitfield 我们设置 (setbit）和获取（getbit）指定位的值都是单个位的， 如果要一次 操作多个位，就必须使用管道来处理。 在 Redis3.2 版本之后，可以使用 bitfield 来操作多个位。 其中 bitfield 有三个子指令 (get set incrby)。它们都可以对指定位片段进行 读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令。 返回指定的二进制范围, get [u|i][offset] [start] u 为无符号数，即没有符号位，获取到的位数组全部都是值。 i 为有符号位，即第一位是符号位，剩下的都是值。 有符号数最多可以获取 64 位，无符号数只能获取 63 位（因为 Redis 协议中的 integer 是有符号数，最大 64 位，不能传递 64 位无符号值〉。如果超出限制，则 Redis 会报错。 127.0.0.1:6379> setbit w 0 1 (integer) 0 127.0.0.1:6379> setbit w 1 1 (integer) 0 127.0.0.1:6379> setbit w 2 1 (integer) 0 127.0.0.1:6379> setbit w 3 1 (integer) 0 127.0.0.1:6379> get w # 把 w 设置成 1111 \"\\xf0\" 127.0.0.1:6379> bitfield w get u4 0 #从 0 开始取 4 位无符号数。 (integer) 15 127.0.0.1:6379> bitfield w get i4 0 #从 0 开始取 4 位有符号数。 (integer) -1 127.0.0.1:6379> bitfield w get u3 2 # 从第 3 位开始取 3 个无符号数。二进制 110 ，十进制 6 (integer) 6 127.0.0.1:6379> bitfield w get i2 3 # 从第 4 位开始取 2 个有符号数。二进制为 10，有符号转十进制要进行补码（即反码后+1），则 10 反码为 01 再 +1，为 10，符号位负，所以十进制为 -2。 (integer) -2 对指定的二进制范围进行设置，并返回它的旧值 set [u|i][offset] [start] 127.0.0.1:6379> set w hello OK 129.0.0.1:6379> bitfield w set u8 8 97 ＃从第 9 个位开始，将接下来的 8 个位用无符号数 97 替换 (integer) 101 127.0.0.1:6379> get w \"hallo\" 对指定的二进制范围执行加法操作，并返回它的旧值。可以通过 increment 参数传入负值来进行减法操作。 [overflow] [warp|fail|sat] incrby [u|i][offset] [increment] Redis 提供了溢出策略的子命令： warp (默认)：使用回绕的方法来处理有符号整数和无符号整数的溢出情况 无符号：回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算，这也是C语言的标准行为。 有符号：上溢将导致数字重新从最小的负数开始计算,而下溢将导致数字重新从最大的正数开始计算。比如：127 的i8执行加一操作 那么得到的结果是-128 sat：使用饱和计算方法处理溢出,也就是说,下溢计算的结果为最小的整数值,而上溢计算的结果为最大的整数值 例子：如果对一个值为120的i8整数执行加10计算,那么命令的结果将i8所能存储的最大整数值为127。相反,如果针对i8值计算造成了下溢,那么这个i8值将被设置为-127。 fail：在这一模式下,命令将拒绝执行那些会导致上溢或者下溢情况出现的计算,并向用户返回空值表示计算未被执行。 warp 例子： 127.0.0.1:6379> set w hello OK 127.0.0.1:6379> bitfield w incrby u4 2 1 (integer) 11 127.0.0.1:6379> bitfield w incrby u4 2 1 (integer) 12 127.0.0.1:6379> bitfield w incrby u4 2 1 (integer) 13 127.0.0.1:6379> bitfield w incrby u4 2 1 (integer) 14 127.0.0.1:6379> bitfield w incrby u4 2 1 (integer) 15 127.0.0.1:6379> bitfield w incrby u4 2 1 (integer) 0 127.0.0.1:6379> set w hello OK 127.0.0.1:6379> bitfield w incrby i4 2 1 (integer) -5 127.0.0.1:6379> bitfield w incrby i4 2 1 (integer) -4 127.0.0.1:6379> bitfield w incrby i4 2 1 (integer) -3 127.0.0.1:6379> bitfield w incrby i4 2 1 (integer) -2 127.0.0.1:6379> bitfield w incrby i4 2 1 (integer) -1 sat 例子： 127.0.0.1:6379> set w hello OK 127.0.0.1:6379> bitfield w overflow sat incrby u4 2 1 (integer) 11 127.0.0.1:6379> bitfield w overflow sat incrby u4 2 1 (integer) 12 127.0.0.1:6379> bitfield w overflow sat incrby u4 2 1 (integer) 13 127.0.0.1:6379> bitfield w overflow sat incrby u4 2 1 (integer) 14 127.0.0.1:6379> bitfield w overflow sat incrby u4 2 1 (integer) 15 127.0.0.1:6379> bitfield w overflow sat incrby u4 2 1 (integer) 15 fail 例子： 127.0.0.1:6379> set w hello OK 127.0.0.1:6379> bitfield w overflow fail incrby u4 2 1 (integer) 11 127.0.0.1:6379> bitfield w overflow fail incrby u4 2 1 (integer) 12 127.0.0.1:6379> bitfield w overflow fail incrby u4 2 1 (integer) 13 127.0.0.1:6379> bitfield w overflow fail incrby u4 2 1 (integer) 14 127.0.0.1:6379> bitfield w overflow fail incrby u4 2 1 (integer) 15 127.0.0.1:6379> bitfield w overflow fail incrby u4 2 1 ＃不执行 (nil) Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/05.HyperLogLog 统计.html":{"url":"Redis/05.HyperLogLog 统计.html","title":"05.HyperLogLog 统计","keywords":"","body":"05.HyperLogLog 统计 为了很好说明这个数据结构的作用，举个例子：通常会有这样的需求，统计网站上每个网页的 PV 和 UV。 PV：采用 Redis 的 String 来计数，每个网页分配一个独立计数器就行。来一个请求就执行 incr 一次。 UV：UV 与 PV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。每个网页都需要带上用户的 id 来记录。通常想到的是使用 Set 数据结构。但当 UV 特别大的时候，Set 就特别浪费空间。那么就需要更好的方案来解决。 使用 Redis 自带的 HyperLogLog 数据结构来统计。它是用来做基数统计的算法，HyperLogLog 的 优点：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 什么是基数? 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 HyperLogLog 有三个指令： pfadd key element [element ...] 添加指定元素到 HyperLogLog 中。 PFCOUNT key [key ...] 统计指定元素的基数估计值。 PFMERGE destkey sourcekey [sourcekey ...] 合并多个基数值成为一个新的基数值。 127.0.0.1:6379> pfadd pv user1 user2 user3 user4 (integer) 1 127.0.0.1:6379> pfcount pv (integer) 4 127.0.0.1:6379> pfadd pv user1 user2 user3 user4 (integer) 0 127.0.0.1:6379> pfcount pv (integer) 4 127.0.0.1:6379> pfadd uv user5 user6 user7 user8 user9 user10 (integer) 1 127.0.0.1:6379> pfcount uv (integer) 6 127.0.0.1:6379> pfmerge mergeV pv uv # 合并 OK 127.0.0.1:6379> pfcount mergeV # 发现得到 10 (integer) 10 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/06.布隆过滤器.html":{"url":"Redis/06.布隆过滤器.html","title":"06.布隆过滤器","keywords":"","body":"06.布隆过滤器 当处理某一个值是不是已经存在 HyperLogLog 中时，它无能为力，它没有提供这样的方法。 场景：当我们使用新闻 APP 来看新闻时，它会不停的给我们推荐新闻，并且过滤到已经看过的重复新闻。怎么实现呢？ 如果将已收看过的新闻数据存在关系型数据库如 mysql 中，当推送系统进行推送时，可以从每个用户的历史记录里进行筛选，以过滤到看过的新闻，但是如果用户量很大并且看过的新闻很多的时候，服务器性能恐怕是跟不上的。 如果采用缓存，那么又得浪费巨大的空间，这个数据一般是线性增长，坚持的了一个月但是没法坚持更长时间。 高级数据结构布隆过滤器（Bloom Filter）闪亮登场了， 它就是专门用来解决这种去重问题的。它在起到去重作用的同时，在空间上还能节省 90% 以上，只是稍微有那么点不精确， 也就是有一定的误判概率。 可以将布隆过滤器理解为不怎么精确的 set 结构。当布隆过滤器说某个值存在时，这个值可能不存在；当它说某个值不存在时，那么就一定不存在。 安装 # 下载包 git clone https://github.com/RedisBloom/RedisBloom.git # 编译，会得到 redisbloom.so make 记录 redisbloom.so 的位置，然后将它加载到 Redis 中，这里有两个方式。 启动时加入# /path/to 改为自己的路径 redis-server --loadmodule /path/to/redisbloom.so 放入配置文件中，我这边配置文件路径是 /usr/local/etc/redis.conf 添加下面代码后保存，同样 /path/to 改为自己的路径。loadmodule /path/to/redisbloom.so 然后重启 brew services restart redis，之后再打开 redis-cli 就可以使用布隆过滤器了 基本命令 添加一个元素，bf.add [key] [value] 判断一个元素是否存在， bf.exists [key] [value] 添加多个元素，bf.madd [key] [value1] [value2]... 判断多个元素是否存在，bf.mexists [key] [value1] [value2]... 127.0.0.1:6379> bf.add demo user1 (integer) 1 127.0.0.1:6379> bf.add demo user2 (integer) 1 127.0.0.1:6379> bf.add demo user3 (integer) 1 127.0.0.1:6379> bf.add demo user4 (integer) 1 127.0.0.1:6379> bf.add demo user5 (integer) 1 127.0.0.1:6379> bf.exists demo user1 (integer) 1 127.0.0.1:6379> bf.exists demo user10 (integer) 0 127.0.0.1:6379> bf.madd demo user6 user7 user8 user9 user10 1) (integer) 1 2) (integer) 1 3) (integer) 1 4) (integer) 1 5) (integer) 1 127.0.0.1:6379> bf.mexists demo user11 user10 user9 1) (integer) 0 2) (integer) 1 3) (integer) 1 控制布隆控制器的误判率，bf.reserve [key] [error_rate] [initial_size] error_rate：错误率，错误率越低，需要的空间越大。 initial_size：预计需要可能放入的数量。 如果不是用 bf.reserve ,默认 error_rate 是 0.01，initial_size 是 100。 127.0.0.1:6379> bf.reserve demo 0.9 10 OK 127.0.0.1:6379> bf.madd demo user6 user7 user8 user9 user10 1) (integer) 1 2) (integer) 1 3) (integer) 0 4) (integer) 0 5) (integer) 0 127.0.0.1:6379> bf.mexists demo user11 user10 user1 1) (integer) 1 2) (integer) 1 3) (integer) 1 当 initial_size 设置过大时，会浪费存储空间，设置过小会影响准确率。所以一定要尽可能估计好元素个数，避免浪费空间。 同样，error_rate 越小，需要的存储空间就越大。对于不需要那么精确的场合，error_rate 稍大一点，无伤大雅。比如新闻 APP 去重新闻一样，误判只有小部分文章不适合被推送。 布隆过滤器的原理 每个布隆过滤器对应到 Redis 的数据结构就是一个大型的 位数组 和几个不一样的无偏 hash 函数。所谓无偏 hash 函数就是能够把 hash 值算的比较均匀，让元素被 hash 映射到位数组中比较均匀。 如图，baidu 这个词被 hash 函数算出值后取模得到得到一个位置，每个函数都会算出一个位置。 当往布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash，算出一个整数索引值，然后对位数组长度取模运算得到一个位置，每个函数都会得到一个位置。再把这些位置都设置为 1，就完成了 add 操作。 向布隆过滤器询问一个 key 是否存在时，与 add 同样的操作，看看这几个值是否为 1，只要有一个为 0 则表示不存在。都为 1 ，并不能说明这个 key 一定存在，而是极有可能存在。因为这个 1 很有可能是别的 key 存在导致的。所以如果这个位数组比较稀疏，判断正确的概率就会很大，否则就小。 空间占用估计 布隆过滤器有两个参数，第一个是预计元素的数量 n，第二个是错误率 f。公式 根据这两个输入得到两个输出，第一个输出是位数组的长度 l，也就是需要的存储空 间大小（ bit ），第二个输出是 hash 函数的最佳数量 k。 hash 函数的数量也会直接影 响到错误率，最佳的数量会有最低的错误率。 k=0.7*(l/n) ＃约等于 f=0.6185^(l/n) ＃ ^表示次方计算，也就是 math.pow 为了省去麻烦，现在有很多现成的在线布隆计算器。 当实际元素超出时，误判率会有怎样变化 f=(1-0.5^t)^k ＃极限近似，k 是 hash 函数的最佳数量。 应用 新闻 app 推送新闻过滤已读新闻。 爬虫系统，过滤已经爬过的 URL。 邮件的垃圾过滤系统，会有某些正常邮件也被放入垃圾邮件目录中，这个就是误判导致，概率很低。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/07.限流.html":{"url":"Redis/07.限流.html","title":"07.限流","keywords":"","body":"07.限流 在高并发场景下有三把利器保护系统：缓存、降级、和限流。 缓存的目的是提升系统的访问你速度和增大系统能处理的容量。 降级是当服务出问题或影响到核心流程的性能则需要暂时屏蔽掉。 限流一般作用于高并发下，除了控制流量外，还有一个应用目的是控制用户行为，避免垃圾请求。如论坛里，控制用户的发帖，回复和点赞等功能。还有商城里如秒杀、抢购、评论、恶意爬虫等。 使用 reids 来实现简单的限流策略 限流算法 常见的限流算法有：计数器，漏桶、令牌桶。 计数器 计数器：记录一段时间窗口内，用户行为总数，判断是否超过限制。 下面是 PHP 的实现方式 isActionAllowed($redis, \"110\", \"reply\", 60 * 1000, 5)); //执行可以发现只有前5次是通过的 } } /** * @param \\Predis\\Client $redis * @param String $userId (用户 id) * @param String $actionName (操作名) * @param Int $period 时间窗口(毫秒) * @param Int $maxCount (最大限制个数) * @return bool * @throws \\Exception */ public function isActionAllowed(\\Predis\\Client $redis, String $userId, String $actionName, Int $period, Int $maxCount) { // 设置键名 $actionKey = sprintf('current-limiting.%s.%s', $actionName, $userId); list($msec, $sec) = explode(' ', microtime()); // 毫秒时间戳 $now = intval(($sec + $msec) * 1000); // 管道 $replies = $redis->pipeline() // value 和 score 都用毫秒时间戳 ->zadd($actionKey, $now, $now) // 移除时间窗口之前的行为记录，剩下的都是时间窗口内的 ->zremrangebyscore($actionKey, 0, $now - $period) // 统计现在个数 ->zcard($actionKey) // 多加一秒过期时间 ->expire($actionKey, $period + 1) // 执行 ->execute(); return $replies[2] 可以发现，这几个 redis 操作都是针对同一个 key，所以使用管道 pipeline 会显著提升效率。但是这个方案也有一个缺陷，就是当量很大时，会占用很大空间，就不适合做限流了（如限定 60 秒，操作不超过 100 万次）。 漏斗限流 顾名思义，算法灵感来自于漏斗。 漏斗容量有限，上面有水龙头灌水，漏斗下面漏水。当灌水速率大于漏水，则漏斗会满，无法再如新水。反之则漏斗永远装不满水。 PHP 实现漏斗法 capacity = $capacity; $this->leakingRate = $leakingRate; $this->leftCapacity = $capacity; $this->lastLeakedTime = time(); } public function makeSpace() { $now = time(); // 距离上一次漏水过去了多久 $deltaTime = $now - $this->lastLeakedTime; // 计算已经腾出了多少空间 $deltaSpace = $deltaTime * $this->leakingRate; // 腾出空间最小单位是 1,太小就忽略 if ($deltaSpace leftCapacity += $deltaSpace; // 记录漏水时间 $this->lastLeakedTime = time(); // 如果剩余容量大于了容器容量,则剩余容量为容器容量 $this->leftCapacity = ($this->leftCapacity > $this->capacity) ? $this->capacity : $this->leftCapacity; } public function watering(float $quota) { //漏水操作 $this->makeSpace(); // 当还有空间时,则减少容器剩余空间 if ($this->leftCapacity >= $quota) { $this->leftCapacity -= $quota; return true; } return false; } } 调用过程 watering(1); } public function demo() { for ($i=0; $iisActionAllowed(\"110\", \"reply\", 15, 0.5)); //执行可以发现只有前15次是通过的 } } 解析代码的关键是 makeSpace() 方法，每次调用前都会触发漏水，腾出多少空间。能腾出多少空间取决于 漏水时间*漏水速率。 分布式的漏斗算法 我们可以把 Funnel 对象存放到 Redis 的 hash 数据结构中。灌水的时候取出进行逻辑计算，再将新值存回到 hash 中。 但是这里有一个问题，无法保证整个过程的原子性。从 hash 中取出，逻辑计算后再存回，这几个过程都无法原子化。意味着需要进行适当的加锁，而一旦加锁，就有失败的可能，加锁失败就需要选择重试或者放弃。重试导致性能下降，放弃就降低用户体验。 于是，Redis-Cell 来了。 Redis 在 4.0 之后提供一个 Redis-Cell 模块，该模块基于漏斗算法，并提供了原子的限流指令。 安装 Redis-Cell 官网：GitHub - brandur/redis-cell: A Redis module that provides rate limiting in Redis as a single command. 在这里下载对应的版本。Releases · brandur/redis-cell · GitHub 我电脑是 mac，下载好后，解压得到 .dylib 文件，如果是 linux 会得到 .so 文件。然后,找到 redis 的配置文件 /usr/local/etc/redis.conf，添加下面一段代码。 loadmodule /usr/local/etc/libredis_cell.dylib 重启 redis,安装就完成了 brew services restart redis Redis-Cell 指令 该模块只有一个指令 cl.throttle。其意思是允许\"某个行为\"的频率是每 60 秒最多 30 次（漏水速率）。漏斗的最大容量为 15。 CL.THROTTLE user123 15 30 60 1 ▲ ▲ ▲ ▲ ▲ | | | | └───── apply 1 token (default if omitted) 可选参数，默认值为 1 | | └──┴─────── 30 tokens / 60 seconds 速率 | └───────────── 15 最大容量 └─────────────────── key \"user123\" 其返回值为： 127.0.0.1:6379> CL.THROTTLE user123 15 30 60 1) (integer) 0 # 0 表示允许，1 表示拒绝 2) (integer) 15 # 漏斗容量 capacity 3) (integer) 14 # 当前容量 leftCapacity 4) (integer) -1 # 如果被拒绝了，需要多少时间后再试（漏斗有空间了，单位秒） 5) (integer) 2 # 多长时间后，漏斗完全空出来（leftCapacity=capacity，单位秒） 在执行指令时，如果被拒绝了，则需要丢弃或重试。重试的话，指令已经算好了时间，直接 sleep 就行，不过会阻塞线程，否则异步定时任务来执行。 漏斗算法的弊端 无法应对短时间的突发流量。 令牌桶算法 令牌桶算法算是漏斗算法的改进，漏斗算法能够限制流出速率，而令牌桶算法能 在限制调用平均速率的同时还允许一定程度上的突发调用 算法描述： 有一个固定容量的桶，按照固定的速率往里面添加令牌。 如果桶满了，新添加的令牌将丢弃。 当请求来时，必须从桶中拿出一个令牌才能继续处理，否则拒绝请求，或者暂存到某个缓冲区等待先从桶中获取令牌再执行请求。 php 实现令牌桶算法 _redis = $redis; $this->_key = $key; $this->_maxCount = $maxCount; } /** * 添加令牌 * @param Int $num * @return Int */ public function add(Int $num = 0) { // 当前剩余令牌数 $leftTokenCount = $this->_redis->llen($this->_key); // 计算最大可加入的令牌数量，不能超过最大令牌数 $num = ($leftTokenCount + $num > $this->_maxCount) ? 0 : $num; if ($num > 0) { // 填充 token，为了简化步骤，这里的 token 值为 1。 $token = array_fill(0, $num, 1); $this->_redis->lpush($this->_key, $token); return $num; } return 0; } /** * 重置令牌桶 */ public function reset() { $this->_redis->del([$this->_key]); $this->add($this->_maxCount); } /** * 获取令牌 * @return string */ public function getToken() { return $this->_redis->rpop($this->_key); } } 执行代码 reset(); for ($i = 0; $i getToken()); } dump($service->add(3)); for ($i = 0; $i getToken()); } 结果 \"1\" \"1\" \"1\" \"1\" \"1\" null null null 3 \"1\" \"1\" \"1\" null null Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/08.GeoHash 算法.html":{"url":"Redis/08.GeoHash 算法.html","title":"08.GeoHash 算法","keywords":"","body":"08.GeoHash 算法 如今移动互联网时代 LBS（Location Based Service 基于位置服务） 应用越来越多，如交友 app 查找附近的人，外卖 app 查找附近的餐馆，地图 app 查找附近的地点等等。那么这些究竟是如何实现的呢？ 我们都知道，地球的位置是使用二维经纬度来表示的，经度 [-180, 180]， 维度 [-90， 90]。只要给出一个地点的经纬度，我们就知道它在地球上的那个位置。 通过 sql 来计算 “附近的人” 比如我们要找“附近的人”，我们的坐标是 (x0,y0)，搜索半径为 r。那么使用如下 SQL 即可： select id from user where x0-r 但是会有什么问题呢： 当并发量大的时候，会搞垮数据库。 计算的是一个矩形的位置，而不是以我为中心 r 公里为半径的圆形方位。 精准度比较低。我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差 使用 Redis 的 GeoHash GeoHash 算法是将二维经纬度数据映射到一维的整数上，把所有的元素都挂载到了一条数轴上。在数轴上找到我们的点，然后就可以获取附近的点了。 将地球看成一个二维平面 然后划分为一系列的正方形方格，好比围棋棋盘。 将地图坐标都表如所在方格中。方格越小，精度越高。 然后进行编码 编码原理：设想一个正方形的蛋糕摆在你面前，二刀下去均分分成四块小正方形，这四个小正方形可以分别标记为 00,01,10,11 四个二进制整数。然后对每一个小正方形继续用二刀法切割一下，这时每个小小正方形就可以使用 4bit 的二进制整数予以表示。然后继续切下去，正方形就会越来越小，二进制整数也会越来越长，精确度就会越来越高。 原理 主要分为三步 将三维的地球变为二维的坐标 在将二维的坐标转换为一维的点块 最后将一维的点块转换为二进制在通过 base32 编码 Redis 的 Geohash 基于 zset。 指令 添加一个或多个，geoadd [key] [lon1] [lat1] [member1] [lon2] [lat2] [member2] ... （lon：经度，lat：维度） 127.0.0.1:6379> geoadd city 120.20000 30.26667 hangzhou 116.41667 39.91667 beijing 121.47 31.23 shanghai (integer) 3 geohash 没有删除，但是 geohash 基于 zset 数据结构，所以直接使用 zrem 就行了 127.0.0.1:6379> zrem city hangzhou (integer) 1 计算两个元素之间的距离，geogist [key] [member1] [member2] [unit] 127.0.0.1:6379> geodist city beijing shanghai km \"1068.3890\" 获取一个或多个元素位置，geopos [key] [member1] [member2]... 127.0.0.1:6379> geopos city beijing shanghai 1) 1) \"116.41667157411575317\" 2) \"39.91667095273589183\" 2) 1) \"121.47000163793563843\" 2) \"31.22999903975783553\" 获取一个或多个元素 hash 值，geohash [key] [member1].... 127.0.0.1:6379> geohash city beijing shanghai 1) \"wx4g14s53n0\" 2) \"wtw3sj5zbj0\" 获取附近的元素，georadiusbymember [key] [member1] [num] [unit] [withcoord|withdist|withhash] [count] [num] [asc|desc] 不会排除自己。 127.0.0.1:6379> geoadd company 116.48105 39.996794 juejin 116.514203 39.905409 ireader 116.489033 40.007669 meituan 116.562108 39.787602 jd 116.334255 40.027400 xiaomi (integer) 5 # 查找 ireader 附近 20KM 以内，最多 3 个公司，按顺序排列，它不会排除自己 127.0.0.1:6379> georadiusbymember company ireader 20 km count 3 asc 1) \"ireader\" 2) \"juejin\" 3) \"meituan\" # 查找 ireader 附近 20KM 以内，最多 3 个公司，按逆序排列，它不会排除自己 127.0.0.1:6379> georadiusbymember company ireader 20 km count 3 desc 1) \"jd\" 2) \"meituan\" 3) \"juejin\" # 三个可选参数 withcoord（坐标）、 withdist（距离）、 withhash（hash 值）。 127.0.0.1:6379> georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc 1) 1) \"ireader\" 2) \"0.0000\" 3) (integer) 4069886008361398 4) 1) \"116.5142020583152771\" 2) \"39.90540918662494363\" 2) 1) \"juejin\" 2) \"10.5501\" 3) (integer) 4069887154388167 4) 1) \"116.48104995489120483\" 2) \"39.99679348858259686\" 3) 1) \"meituan\" 2) \"11.5748\" 3) (integer) 4069887179083478 4) 1) \"116.48903220891952515\" 2) \"40.00766997707732031\" 根据坐标查找附近元素，georadius [key] [lon] [lat] [num] [unit] [withcoord|withdist|withhash] [count] [num] [asc|desc] 127.0.0.1:6379> georadius company 116.514202 39.905409 20 km withdist count 3 asc 1) 1) \"ireader\" 2) \"0.0000\" 2) 1) \"juejin\" 2) \"10.5501\" 3) 1) \"meituan\" 2) \"11.5748\" 注意事项 在一个地图应用中，车的数据，餐馆的数据，人的数据可能有几千万条，如果使用 redis 的 geo 数据结构，它们将被全部放在一个 zset 集合中。 在 Redis 集群环境中，集合可能从一个节点迁移到另一个节点，那么单个 key 的数据过大，会导致集群迁移工作造成较大影响。 在集群环境中，单个 key 的大小不要超过 1MB，否则会导致集群迁移出现卡顿现象，影响线上服务正常运行。 所以，一般建议要对 geo 数据使用单独的 redis 实力部署，不使用集群。 如果数据量过亿，甚至更大，就可以对 geo 数据进行拆分，按国家、按省份、按市、按区域拆分，显著降低单个 zset 集合大小。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/09.大海捞针-scan.html":{"url":"Redis/09.大海捞针-scan.html","title":"09.大海捞针-scan","keywords":"","body":"09.大海捞针-scan 在平时 Redis 维护过程中，可能需要从成千上万个 key 中找到特定前缀的 key 列表来手动处理数据。Redis 给了几种方法来处理： keys 指令 指令：keys [正则] 127.0.0.1:6379> keys * 1) \"company\" 2) \"city\" 3) \"demo\" 127.0.0.1:6379> keys c* 1) \"company\" 2) \"city\" 这个指令虽然方便，但是有几个缺点： 没有 limit offset 参数，一次性吐出所有满足条件的 key，如果有上万个那么结果将刷屏。 keys 算法是遍历算法，时间复杂度是 O(n)。如果有上千万条 key，执行这个指令的时候服务器会卡顿。由于 Redis 是单线程程序，顺序执行所有指令，其他指令必须等 keys 指令执行完成后才可继续执行。 为了解决这个问题，Redis 又推出了 scan 指令 scan 指令 scan 指令的特点： 时间复杂度是 O(n)，但是它是通过游标分步进行的，不会阻塞线程。 提供 limit 参数，可以控制返回结果的最大数量，但是 limit 只是一个 hint（提示）,返回结果可多可少。 同 keys 一样，提供匹配功能。 服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数。 返回的结果中可能有重复，需要客户端去重，很重要！！！。 遍历的过程中如果有数据修改，不确定是否能遍历到。 单次返回的结果为空不代表遍历结束，而是看返回的游标值是否为零。 指令：scan [cursor] match [匹配] [count]。cursor=游标 事先造 10 个 key。 127.0.0.1:6379> scan 0 match key* count 3 1) \"14\" 2) 1) \"key6\" 2) \"key8\" 3) \"key20\" 127.0.0.1:6379> scan 14 match key* count 3 1) \"1\" 2) 1) \"key7\" 2) \"key5\" 127.0.0.1:6379> scan 1 match key* count 3 1) \"11\" 2) 1) \"key9\" 2) \"key4\" 127.0.0.1:6379> scan 11 match key* count 3 1) \"15\" 2) 1) \"key1\" 2) \"key3\" 127.0.0.1:6379> scan 15 match key* count 3 1) \"0\" 2) 1) \"key2\" 返回第一个结果是游标，作为第二次执行指令。可以理解为第二页的页码，当游标的值为 0 时，则代表遍历结束，也就是平时我们所说的尾页。 除了 scan，其他容器也有类似指令，如 zscan 遍历 zset 集合，hscan 遍历 hash 字典的集合，sscan 遍历 set 集合。 大 key 扫描 为了定位大 key，又想避免线上 Redis 卡顿，官方为我们带来了一个指令 --bigkeys。 redis-cli -h127.0.0.1 -p 7001 --bigkeys 如果担心这个指令会大幅提升线上 Redis 的 ops。可以加一个休眠参数 redis-cli -h127.0.0.1 -p 7001 --bigkeys -i 0.1 这个参数代表每隔 100 条就会休眠 0.1s。 结果 ~ redis-cli --bigkeys -i 0.1 # Scanning the entire keyspace to find biggest keys as well as # average sizes per key type. You can use -i 0.1 to sleep 0.1 sec # per 100 SCAN commands (not usually needed). [00.00%] Biggest string found so far 'key6' with 1 bytes [00.00%] Biggest zset found so far 'city' with 2 members [00.00%] Biggest zset found so far 'company' with 5 members -------- summary ------- Sampled 13 keys in the keyspace! Total key length in bytes is 56 (avg len 4.31) Biggest string found 'key6' has 1 bytes Biggest zset found 'company' has 5 members 0 lists with 0 items (00.00% of keys, avg size 0.00) 0 hashs with 0 fields (00.00% of keys, avg size 0.00) 10 strings with 10 bytes (76.92% of keys, avg size 1.00) 0 streams with 0 entries (00.00% of keys, avg size 0.00) 0 sets with 0 members (00.00% of keys, avg size 0.00) 1 MBbloom--s with 0 ? (07.69% of keys, avg size 0.00) 2 zsets with 7 members (15.38% of keys, avg size 3.50) Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/10.内存回收机制.html":{"url":"Redis/10.内存回收机制.html","title":"10.内存回收机制","keywords":"","body":"10.内存回收机制 面试题: redis删除很多key, 内存不减少的原因? 答：因为操作系统回收内存是以「页」为单位，如果这个页中只要有一个 key 还在使用，那么这个页就不会被回收。假如 redis 内存有 10 个 G，现在删除 1 个 G 的 key，但是这些 key 是分散在各个内存页中，这就导致内存不会立刻被回收。 如果执行了 flushdb（注：删除所有 key），然后再观察内存，则发现内存被回收。 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/11.主从同步.html":{"url":"Redis/11.主从同步.html","title":"11.主从同步","keywords":"","body":"11.主从同步 CAP 原理 所谓 CAP 即： C - Consistent ，一致性 A - Availability ，可用性 P - Partition tolerance ，分区容忍性 分布式系统节点往往分布在不同机器上，当机器间网络断开时，则称之为「网络分区」。 一旦网络分区，将会导致主从系统之间无法同步数据，导致「一致性」无法满足。除非牺牲「可用性」，暂停分布式节点服务，在网络分区时不在提供修改数据功能，知道网络恢复为止。 一句话概括 CAP 原理就是——网络分区发生时，一致性和可用性两难全。 最终一致性 Redis 的主从同步是异步的，所以分布式的 Redis 不满足「一致性」要求。但是 Redis保证「最终一致性」。即使网络分区时，主节点依旧可以对外提供正常服务保证「可用性」。当网络恢复时，从节点会努力追赶主节点，最终达到一致。 主从同步 Redis 同步支持主从同步和从从同步，从从同步是后续版本增加的。 增量同步 Redis 同步是指令流，主节点会将对自己产生修改性的指令记录在本地内存的 buffer 中，然后异步的同步给从节点。从节点一边执行同步指令，一边向主节点反馈自己同步到哪了。 但是由于内存的 buffer 是有限的，Redis 的复制内存 buffer 是一个环形数组，如果该数组满了，则会从头覆盖前面的指令。 如因为网络分区，导致从节点无法与主节点进行同步，当网络恢复时，主节点中没有同步的指令在 buffer 中被后续指令给覆盖了。 快照同步 快照同步是一种非常耗资源的操作，其过程是在主节点上进行一次 bgsave，将当前内存的数据全部快照到磁盘文件中，然后将快照文件传给从节点，从节点接收完毕后，立即执行全量加载，加载之前会将当前内存的数据清空。加载完毕后通知主节点进行增量同步。 整个快照同步过程中，主节点的复制 buffer 还是在一直向前一定，如果快照同步时间过长或者复制 buffer 过小，也会导致增量指令在 buffer 中被覆盖，导致增量同步无法完成，又会再一次发起快照同步，如此可能造成死循环。 所以，需要设置一个合适的复制 buffer 大小，避免快照复制死循环。 增加从节点 当从节点加入到集群时，先执行一次快照同步，再进行增量同步。 无盘复制 主节点进行快照同步时，会进行很重的 io 操作。对于非 ssd 磁盘存储时，会对系统造成较大的负载。特别是当系统正在进行 AOF 的 fsync 操作时如果发生快照，fsync 将会被推迟执行，这就会严重影响主节点的服务效率。 所以从 redis 的 2.8.18 版开始支持无盘复制。所谓无盘复制是指，主节点直接通过套接字（socket）连接从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一边将序列化的内容发送给从节点，从节点还是跟之前一样，接收完毕后，再一次性加载。 wait Redis 的复制是异步的，wait 指令可以使其变成同步复制，却表系统的一致性（不严格）。 > set key value OK > wait 1 0 (integer) 1 wait 提供两个参数，第一个参数是从库的数量 N，第二个参数是时间 T（毫秒）。它表示 等待 wait 之前的所有写操作同步到 N 个库 (也就是确保 N 个从库的同步没有滞后)，最多等待 T 秒。如果 T=0 ，则表示无限等待直到 N 个从库同步完成达成一致。 如果出现网络分区，wait 指令的第二个参数 T=0，那么主从同步将无法执行，wait 命令将永远阻塞，Redis 服务器将丧失可用性。 Redis主从同步： 1:增量追赶，写指令流同步 2:增量太慢了，全量追赶，快照同步 3:无盘复制，生产快照是一个遍历的过程 主从主要是为了保障Redis的高可用性，同时也能兼顾提升性能 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "},"Redis/12.Redis 集群-sentinel.html":{"url":"Redis/12.Redis 集群-sentinel.html","title":"12.Redis 集群-sentinel","keywords":"","body":"12.Redis 集群-sentinel sentinel 之前只说到主从方案，最终一致性。那么现在有个问题，如果当主节点发生故障时，就必须人为来操作修改主节点等等，这样效率太低，Redis 官方提供了一个方案-sentinel（哨兵）。 如图所示，Redis-sentinel 可以看做是集群高可用的心脏，负责监视组从节点的健康状态，当主节点发生故障时，会从从节点中选取最优节点作为主节点。 首先，客户端连接集群时，会首先连接 Redis-sentinel ，Redis-sentinel 会查询主节点的地址，并告诉客户端。如此应用程序无需重启即可完成主从节点切换。 如下图，当主节点发生故障时，原来的主从连接将断开，客户端和原来的主节点也会断开。从节点被提升为主节点后，其他从节点和新主节点建立复制关系。 客户端会和新主节点继续进行交互。Redis-sentinel 会持续监视已经挂掉的主节点，待其恢复后，会变成新的从节点，集群将会调整为下图。原来的主节点变成了从节点，与新的主节点建立复制关系。 消息丢失 Redis 的复制关系是异步的，当主节点挂掉的时候，可能还没有将所有消息同步给从节点，那么这部分消息可能丢失。如果延迟特别大，丢的消息也就会越多。 sentinel 无法保证消息完全不丢失，但是肯依尽可能的保证少丢失。有下面两个选项 min-slaves-to-write 1 min-slaves-max-lag 10 第一个参数表示，至少有一个从节点在进行正常复制，否则停止对外服务，丧失可用性。 那何为正常复制，何为异常复制呢？这个是由第二个参数控制，它单位是秒，表示 10s 没收到从节点反馈，就意味从节点同步不正常，要么网络分区，要么一直没反馈。 配置 基于 homestead 环境 主从配置 # 跳转到 redis 配置目录 cd /etc/redis # 复制两个从节点配置 sudo cp redis.conf redis-6381.conf sudo cp redis.conf redis-6382.conf 打开其中一个从节点配置文件，修改。 #修改 port 6381 #修改 pidfile /var/run/redis/redis-server-6381.pid #修改 logfile /var/log/redis/redis-server-6381.log # 增加一行 slaveof 127.0.0.1 6379 保存之后，启动两个从节点实例 sudo redis-server /etc/redis/redis-6381.conf sudo redis-server /etc/redis/redis-6382.conf 然后通过 redis-cli 进入主节点，使用命令 info 查看。 127.0.0.1:6379> info . . . # Replication role:master connected_slaves:2 slave0:ip=127.0.0.1,port=6381,state=online,offset=784,lag=1 slave1:ip=127.0.0.1,port=6382,state=online,offset=784,lag=1 master_replid:125d233d1f1ddf1f52300d8ca4720a979b01283f master_replid2:0000000000000000000000000000000000000000 master_repl_offset:798 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:798 省略了一部分结果，我们可以看到， role:master #本机是『主节点』 connected_slaves:2 #有2个『从节点』 slave0:ip=127.0.0.1,port=6381,state=online,offset=784,lag=1 slave1:ip=127.0.0.1,port=6382,state=online,offset=784,lag=1 \"从\"服务器iP地址和端口是 6381 和 6382 接下来我们试验下,首先在主节点设置一个 key。 127.0.0.1:6379> set name demo1 OK 127.0.0.1:6379> get name \"demo1\" # 切换为从节点 vagrant@homestead:/etc/redis$ redis-cli -p 6381 127.0.0.1:6381> get name \"demo1\" 可以看到从节点已经有值，表示主从节点已经有复制关系。 然后尝试在从节点进行写操作 127.0.0.1:6381> set name lisi (error) READONLY You can't write against a read only slave. 报错，说明从节点只能读取，这就是读写分离。 在 laravel 中配置主从 在 config/database.php 中修改、 [ 'client' => env('REDIS_CLIENT', 'predis'), 'cluster' => false, 'default'=>[ 'tcp://127.0.0.1:6379', 'tcp://127.0.0.1:6381', 'tcp://127.0.0.1:6382', ], ], ] sentinel 由于当前环境没有安装 redis-sentinel，所以先安装 sudo apt-get install redis-sentinel 安装完成后，/etc/redis 目录下才会有 sentinel.conf 文件,打开文件并修改 port 26379 pidfile \"/var/run/redis-sentinel-26379.pid\" logfile \"/var/log/redis/redis-sentinel-26379.log\" #主节点别名为mymaster，后面是ip和端口，2代表判断主节点失败至少需要2个sentinel节点同意 sentinel monitor mymaster 11.11.11.11 6379 2 # 设置密码 # sentinel auth-pass mymaster 123456 #主节点故障30秒后启用新的主节点 sentinel down-after-milliseconds mymaster 30000 #故障转移时最多可以有1个从节点同时对主节点进行数据同步，数字越大，用时越短，存在网络和 IO 开销 sentinel parallel-syncs mymaster 1 #故障转移超时时间180s：a 如果转移超时失败，下次转移时时间为之前的2倍；b 从节点变主节点时，从节点执行 slaveof no one 命令一直失败的话，当时间超过180S时，则故障转移失败；c 从节点复制新主节点时间超过180S转移失败 sentinel failover-timeout mymaster 180000 然后复制两份 sentinel.conf vagrant@homestead:/etc/redis$ sudo cp sentinel.conf sentinel-26381.conf vagrant@homestead:/etc/redis$ sudo cp sentinel.conf sentinel-26382.conf 分别打开修改 pidfile \"/var/run/sentinel/redis-sentinel-26381.pid\" logfile \"/var/log/redis/redis-sentinel-26381.log\" port 26381 # myid 为当前 sentinel 的 id，随意设置一个就行，只要不重复，最开始我就是没修改这个，导致始终无法建立多个 sentinel sentinel myid 8f2969662f6bcd3553661608c213a3d637ab9987 上面配置完成后，启动 vagrant@homestead:/etc/redis$ sudo redis-sentinel sentinel.conf vagrant@homestead:/etc/redis$ sudo redis-sentinel sentinel-26381.conf vagrant@homestead:/etc/redis$ sudo redis-sentinel sentinel-26382.conf 当启动后，查看日志发现 /var/log/redis/redis-sentinel.log 29329:X 25 Sep 17:15:33.445 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 29329:X 25 Sep 17:15:33.445 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=29329, just started 29329:X 25 Sep 17:15:33.445 # Configuration loaded 29330:X 25 Sep 17:15:33.448 * Increased maximum number of open files to 10032 (it was originally set to 1024). # 启动模式为 sentinel， 端口为 26379 29330:X 25 Sep 17:15:33.450 * Running mode=sentinel, port=26379. # 它的 id 为 8f2969662f6bcd3553661608c213a3d637cd2331 29330:X 25 Sep 17:15:33.451 # Sentinel ID is 8f2969662f6bcd3553661608c213a3d637cd2331 # redis 集群主节点为 端口号 6379，当主节点发生故障时，需要至少两个 quorum 投票确定新主节点 29330:X 25 Sep 17:15:33.451 # +monitor master mymaster 127.0.0.1 6379 quorum 2 # 发现了两个新从节点 29330:X 25 Sep 17:15:33.455 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379 29330:X 25 Sep 17:15:33.464 * +slave slave 127.0.0.1:6382 127.0.0.1 6382 @ mymaster 127.0.0.1 6379 # 发现了两个新 sentinel 29330:X 25 Sep 17:15:47.382 * +sentinel sentinel 8f2969662f6bcd3553661608c213a3d637ab9987 127.0.0.1 26381 @ mymaster 127.0.0.1 6382 29330:X 25 Sep 17:15:49.633 * +sentinel sentinel 8f2969662f6efg3553661608c213a3d637cd0000 127.0.0.1 26382 @ mymaster 127.0.0.1 6382 这个时候再打开 sentinel.conf 会发现多了几行，表示已知的从节点和 sentinel。 sentinel known-slave mymaster 127.0.0.1 6381 sentinel known-slave mymaster 127.0.0.1 6382 sentinel known-sentinel mymaster 127.0.0.1 26381 8f2969662f6bcd3553661608c213a3d637ab9987 sentinel known-sentinel mymaster 127.0.0.1 26382 8f2969662f6efg3553661608c213a3d637cd0000 sentinel current-epoch 0 当杀死 master 时，sentinel 将会从新选举新的 master 我们进入 6381 查看状态,6381 已经是 master了 并且拥有一个 6382 的slave 127.0.0.1:6381> info Replication # Replication role:master connected_slaves:1 slave0:ip=127.0.0.1,port=6382,state=online,offset=405135,lag=0 master_replid:2fb1ec7df33d87f7489d451e2a4b1ba379c16038 master_replid2:f2291a4914b906e8ce6b88203d755ed9b539ab0a master_repl_offset:405135 second_repl_offset:58660 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:4800 repl_backlog_histlen:400336 重新启动 6379 后,并且将 6379 设置为 6381 的 slave。 29330:X 25 Sep 17:32:11.190 * +slave slave 127.0.0.1:6382 127.0.0.1 6382 @ mymaster 127.0.0.1 6381 29330:X 25 Sep 17:32:41.251 # +sdown slave 127.0.0.1:6382 127.0.0.1 6382 @ mymaster 127.0.0.1 6381 29330:X 25 Sep 17:32:41.500 # -sdown slave 127.0.0.1:6382 127.0.0.1 6382 @ mymaster 127.0.0.1 6381 sentinel 在 laravel 中使用 'sentinel', 'service' => 'mymaster']; $redis = new \\Predis\\Client($sentinels, $options); $redis->set('name','jack'); dd($redis->info()); sentinel 几个常用命令 SENTINEL masters #查看主节点信息 SENTINEL sentinels # 查看其他 sentinel 信息 SENTINEL slaves #查看对应集群的从节点信息 SENTINEL failover #进行故障转移 SENTINEL get-master-addr-by-name #查看当前的主节点地址 参考： Redis 哨兵使用以及在 Laravel 中的配置 | Laravel China 社区 Redis Sentinel服务配置 - 漫天雪_昆仑巅 - CSDN博客 Copyright © Kagami丶 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 18:08:06 "}}